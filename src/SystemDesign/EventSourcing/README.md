# Event sourcing

Event sourcing - паттерн при котором хранится не конечное состояние объекта, а череда событий (event) произошедших
с объектом. Например, мы храним не баланс некоего счета, а список операций (пополнение и снятие) с этим счетом. Хранение
событий может происходить в любой базе, которая поддерживает быструю запись в конец и получение данных по некоему ключу.

Не стоит путать с Event Streaming, последнее это в целом про событийную модель взаимодействия, а первое про устройство
хранение агрегатов. Поэтому Event Sourcing можно применить лишь в одном сервисе, а все другие продолжат использовать 
старые инструменты для хранения данных. 

Использовать event sourcing имеет смысл в следующих сценариях:
1) Аудит событий - краеугольное бизнес требование. Event sourcing по своей природе является моделью событий для аудита.
2) Temporal запросы - необходимо знать состояние объекта в произвольный момент времени
3) Интеграция со сторонними сервисами - если после изменения агрегата необходимо отправить событие в сторонний сервис, то
могут возникнуть сложности с транзакционностью (запись в базу и отправление события). Event sourcing по своей природе
решает эту проблему поскольку отказывается от хранения состояния
4) Архитектура событий - если система представляет собой событийную

Данное решение повлияет на общую архиектуру приложения, стоит помнить, что любое изменение агрегата происходит через 
событие. Так же модели становятся более богатыми, поскольку модель должно знать, как реагировать на тот или иной ивент.
Так же стоит максимум информации записывать в ивент и по максимуму освобождать от логики методы реагирования на ивент.
Пример: у нас исходя из ивентов пополнения счета происходит расчет налогов. Неправильный подход: процент налога записан
в метод обработки ивента. Правильный подход: процент налога записан в ивент (а соответственно в базу). Необходимо это по
той причине, что процент налога может измениться. Аналогично со всеми вызовами внешних сервисов. Лучше результат вызова
записать в ивент.

Что же делать, если событий очень много? Считать их может быть долго, да и загружать все в оперативную память не 
хочется. Есть два подхода: схлопывание последовательных событий одинакового типа и хранение снапшота. В первом подходе 
если пользователь потратил со счета 10р, а следом еще 5р, то иногда эти события можно схлопнуть и хранить одно. Во 
втором подходе раз в какое-то время или какое-то количество событий высчитывается снапшот нашего агрегата и записывается
в базу данных. Дальнейшая попытка получения актуальных данных состоит из взятия снапшота и расчета только свежих событий.
Оба подхода можно применять одновременно.

Агрегат может меняться по ходу жизни приложения. В обычном доменном подходе используются транзакции. В подходе event 
sourcing используются два подхода: разные версии событий (а соответственно и метод под каждую версию события) или 
приведение старых событий к актуальной версии (например если в событие добавилось новое поле, стоит записывать значение
по умолчанию).

Возникает проблема при выборке данных, например, если нам нужно 100 самых богатых клиентов. Не хочется по события 
считать состояние каждого счета. Как правило, для выборок данных event sourcing использует CQRS подход. Создается база
для чтения, в которой записывается актуальное состояние объекта (события реплицируются из базы событий). Тут стоит 
помнить, что в базе для чтения появится конечная согласованность и ее нельзя использовать для точных запросов.

В итоге имеем следующие плюсы:
- Аудит лог из коробки
- Хорошая производительность на запись и изменение данных
- Можно делать темпоральные запросы
- Можно строить гибкую аналитику, так как храним все данные

И следующие минусы:
- Крутая кривая обучения, необычная технология для разработчиков
- Рефакторинг/изменение событий/версионность может вызывать сложности
- Необходим CQRS паттерн для выборок по данным

Хороший пример использования: биллинг некой системы

Источники:
1) https://microservices.io/patterns/data/event-sourcing.html
2) https://www.youtube.com/watch?v=e5EXP3QuVko