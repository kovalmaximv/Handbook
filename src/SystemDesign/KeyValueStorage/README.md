# Архитектура Key Value storage
Не совсем обычное system-design задание, я его включил скорее для закрепления теоретических знаний по блоку БД.

## Требования к key value storage:
- Размер одной пары ключ-значения небольшой: меньше 10КБ
- Большая доступность базы (AP система)
- Хорошая масштабируемость (возможность хранения биг даты)
- Автоматическое масштабирование (количество серверов динамически изменяется вследствие нагрузки)
- Гибко настраиваемая консистентность
- Низкая задержка на вызовы

## CAP теорема
CAP теорема говорит нам о том, что в распределенных системах нельзя добиться согласованности и доступности 
одновременно. В общем виде теорема звучит так: `в распределенных системах можно предоставить только 2 из 3 свойств:
согласованность, доступность и partition tolerance (возможность партицирования? Перевода лучше я не встречал)`.

**Согласованность** - все клиенты в любой момент времени видят одинаковые данные независимо от того, к какой ноде 
они подключены.  
**Доступность** - запрос пользователя в любой момент времени получит ответ, даже если некоторые ноды не работают.  
**Partition tolerance** - система продолжает работать несмотря на сетевые разрывы между нодами.

Система может быть CP или AP, но не может быть CA поскольку распределенная система обязана выдерживать разрывы между
нодами, иначе нас такая система не интересует. 

## Партиционирование данных
По мере роста кол-ва данных их становится невозможно держать на одном сервере. Есть идея разделять данные между 
серверами и для этого используется горизонтальное партиционирование (его еще называют шардирование). В таком случае 
данные на основе ключа шардирование распределяются на хранение между несколькими серверами. Для распределения лучше
всего использовать алгоритм `consistent hashing` так как он позволяет минимизировать перетасовку данных при изменении
количества серверов. 

Правильное шардирование данных позволяет ускорить выполнение запросов, поскольку запрос выполняется параллельно на всех
шардах. Если в запросе фигурирует ключ шардирования и запрос можно выполнить только на одном шарде, то это и происходит.

## Реплицирование данных
Для обеспечения высокой доступности и надежности хранения данных используют реплицирование. Идея в том, чтобы хранить 
все данные в нескольких копиях на разных серверах. Тогда если один сервер перестанет работать, данные можно будет 
прочитать из другого сервера. В `consistent hashing` удобно выбирать сервера для реплицирования: это просто следующие 
несколько серверов после основного по часовой стрелке. 

## Согласованность
Типы согласованности:
1) Строгая согласованность - любая операция чтения вернет самые последние записанные данные
2) Слабая согласованность - операция чтения может вернуть устаревшие данные
3) Конечная согласованность - вид слабой согласованности. Спустя неопределенное время данные между репликами 
синхронизируются и операция чтения будет возвращать последние данные

Данные между репликами должны быть синхронизированы (согласованы). Рассмотрим параметры системы для более тонкой
настройки согласованности (read/write quorum):
1) N = кол-во реплик
2) W = write quorum. Чтобы запись засчиталась успешной, эта запись должна быть подтверждена W репликами
3) R = read quorum. Чтобы чтение засчиталось успешным, нужно дождаться ответа минимум R реплик

- W + R > N, то строгая согласованность гарантирована. Будет хотя бы один узел который содержит последние данные и
мы дождемся его ответа.  
- W + R < N, то строгая согласованность не гарантирована. Можно прочитать устаревшие данные.  
- R = 1, W = N, оптимизация для чтения
- R = N, W = 1, оптимизация для записи

Для определения несогласованности в БД используется версионность (например vector clock). Vector clock помечает каждую
запись парой [номер сервера, номер версии данных]. При каждой записи происходит выбор:
1) Инкремент пары, если пара с таким сервером уже существует.
2) Создание новой пары, если пары с таким сервером нет.

На основе таких пар можно определить несогласованность данных. Например если пара сменилась с D([s0, 1], [s1, 1])] на  
D([s0, 1], [s1, 2]) - то все хорошо (номера версий увеличиваются). Если с D([s0, 1], [s1, 2]) на D([s0, 2], [s1, 1])
- то произошло рассогласование (номера версий скачут).

## Итог
Проверим выполнение требований:
1) Большая доступность базы: для чтения - репликация данных, для записи - репликация + версионность данных
2) Хорошая масштабируемость (возможность хранения биг даты) - consistent hashing + репликация
3) Автоматическое масштабирование - consistent hashing
4) Гибко настраиваемая согласованность - read/write quorum