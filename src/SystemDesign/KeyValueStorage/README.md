# Архитектура Key Value storage
Не совсем обычное system-design задание, я его включил скорее для закрепления теоретических знаний по блоку БД.

## Требования к key value storage:
- Размер одной пары ключ-значения небольшой: меньше 10КБ
- Большая доступность базы (AP система)
- Хорошая масштабируемость (возможность хранения биг даты)
- Автоматическое масштабирование (количество серверов динамически изменяется вследствие нагрузки)
- Гибко настраиваемая консистентность
- Низкая задержка на вызовы

## CAP теорема
CAP теорема говорит нам о том, что в распределенных системах нельзя добиться согласованности и доступности 
одновременно. В общем виде теорема звучит так: `в распределенных системах можно предоставить только 2 из 3 свойств:
согласованность, доступность и partition tolerance (возможность партицирования? Перевода лучше я не встречал)`.

**Согласованность** - все клиенты в любой момент времени видят одинаковые данные независимо от того, к какой ноде 
они подключены.  
**Доступность** - запрос пользователя в любой момент времени получит ответ, даже если некоторые ноды не работают.  
**Partition tolerance** - система продолжает работать несмотря на сетевые разрывы между нодами.

Система может быть CP или AP, но не может быть CA поскольку распределенная система обязана выдерживать разрывы между
нодами, иначе нас такая система не интересует. 

## Партиционирование данных
По мере роста кол-ва данных их становится невозможно держать на одном сервере. Есть идея разделять данные между 
серверами и для этого используется горизонтальное партиционирование (его еще называют шардирование). В таком случае 
данные на основе ключа шардирование распределяются на хранение между несколькими серверами. Для распределения лучше
всего использовать алгоритм `consistent hashing` так как он позволяет минимизировать перетасовку данных при изменении
количества серверов. 

## Реплицирование данных
Для обеспечения высокой доступности и надежности хранения данных используют реплицирование. Идея в том, чтобы хранить 
все данные в нескольких копиях на разных серверах. Тогда если один сервер перестанет работать, данные можно будет 
прочитать из другого сервера. В `consistent hashing` удобно выбирать сервера для реплицирования: это просто следующие 
несколько серверов после основного по часовой стрелке. 

## Согласованность