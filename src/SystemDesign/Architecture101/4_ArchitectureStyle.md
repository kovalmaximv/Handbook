# Архитектурные стили
### Минусы распределенных архитектур
Распределенные архитектуры (например микросервисы) **мощнее и более масштабируемые**, но имеют свои минусы:
1) **Проблемы с надежностью сети**: абсолютно надежных сетей не бывает и из-за этого страдает надежность распределенных 
архитектур. 
2) **Проблемы с задержками сети**: При проектировании систем архитектору необходимо знать среднее время задержки сети. 
Если задержка 100мс, то на 10 последовательных вызовов потратится уже целая секунда. Так же необходимо знать 95-99 
перцентили задержек, большие перцентили могут убить производительность системы. 
3) **Пропускная способность сети ограничена**: даже если каждый запрос весит пару килобайт, то при большом количестве 
пользователей это может забить пропускную способность вашей сети. Чтобы этого избежать необходимо использовать минимум
полей в контрактах API, использовать GraphQL или другие селекторы необходимых полей
4) **Сеть небезопасна**: в распределенной системе становится больше открытых эндпоинтов, их все необходимо защищать 
должным образом.
5) **Топология сети может постоянно меняться**: что может вызывать неработоспособность системы
6) **Сетью занимаются несколько администраторов**: что может усложнить получение информации о сети
7) **Сеть дорогое удовольствие**: необходимое оборудование для сети надо купить/арендовать и поддерживать
8) **Сеть неоднородна**: в одной сети может быть оборудование нескольких произодвителей, что не делает сеть более устойчивой

Так же распределенные структуры усложняют ведение логов (необходима трассировка), появляется проблема распределенных
транзакций (что вводит конечную согласованность).

# Многоуровневная архитектура
Самый распространенный архитектурный стиль. Все благодаря своей простоте, известности и невысоким затратам. 

Компоненты в многоуровневой архитектуре собраны в логические горизонтальные уровни. Каждый уровень выполняет 
определенную задачу (отображение интерфейса пользователю, реализация бизнес-логики и тд). Ограничений в количестве 
уровней нет, но большинство таких архитектур состоит из 4 частей: представление, бизнес-логика, сохранение информации, 
база данных. В некоторых случаях два последних уровня объединяются в один. 

![img.png](../../../img/architecture/n_tier_architecture.png)

Эта концепция слоей и разделения ответственности упрощает разработку, сопровождение и тестирование каждого отдельного 
слоя. Компоненты в рамках одного слоя работают в единой области действия, относящейся к данному уровню. Компромиссом 
является скорость изменения архитектуры. При внесении правок необходимо править все слои архитектуры.

Многоуровневая архитектура разбивается _по техническому принципу_ (существует еще _предметное разбиение_). Компоненты
разбиваются не по предметным областям (например клиенты, товары, корзина), а по своей технической архитектурной роли в 
проекте.

Каждый уровень в такой архитектуре может быть открытым или закрытым. Для объяснения этого принципа представим, что запрос
пользователя идет сверху вниз по слоям архитектуры. Закрытый слой означает, что каждый запрос пользователя обязан его
посетить, пропускать его нельзя. Открытый слой наоборот можно при некоторых условиях пропустить и перейти к слоям ниже.

Закрытые уровни поддерживают концепцию _уровней изоляции_. Концепция уровней изоляции состоит в том, что изменения 
сделанные на одном уровне, как правило, не влияют на другие уровни. Только при условии, что контракты остаются 
неизменными. Закрытые уровни, тем самым, помогают изолировать изменения в архитектуре. Тем не менее бывают случаи, когда
необходим открытый уровень. Например, в уровне бизнес-логики есть некий компонент и мы хотим, чтобы уровень 
представления ни под каким предлогом не мог получить доступ к этому компоненту. В таком случае этот особенный компонент
следует вынести в отдельный уровень ниже уровня бизнес логики и сделать его _открытым_. Слой представления не будет 
иметь к нему прямого доступа, ведь его защищает закрытый слой бизнес-логики. А слой бизнес логики сможет продолжить
общаться с особенным компонентом и сможет пропускать запросы дальше, если для запроса этот компонент не нужен.

Многоуровневая архитектура является неплохой отправной точкой, когда еще точно неизвестно, какой в конечном итоге 
будет выбран архитектурный стиль. В таком случае следует минимально переиспользовать код и наследование объектов. Тогда
переход к другому архитектурному стилю будет проще. 

При использовании данной архитектуры следует избегать _антипаттерна "воронка"_. Антипаттерн возникает, когда слой 
представления отвечает за простую логику, например отображение данных о клиенте, и большинство запросов слоя 
представления просто проксируются следующими слоями. Сдеующие слои не делают никакой полезной работы, просто передают
запрос далее. В любой архитектуре будут встречаться такие сценарии, допустимо, когда из всех запросов данному 
антипаттерну соответствуют 20%. Если более, то скорее всего выработанная архитектура не подходит сценарию использования.

**Когда использовать данный стиль**: Многоуровневый архитектурный стиль считается вполне подходящим для небольших 
простых приложений или веб-сайтов. Он также является удачным архитектурным выбором, особенно в качестве отправной точки,
когда еще не ясно, какую архитектуру следует использовать. Из-за своей простоты и освоенности многоуровневая
архитектура является, наверное, одним из самых дешевых архитектурных стилей. По мере усложнения приложения прослеживается
негативное влияние многоуровневой архитектуры на такие свойства, как сопровождаемость, гибкость, тестируемость и 
развертываемость. 

Одна звезда в оценочной таблице свойств означает, что данное архитектурное свойство плохо поддерживается в архитектуре, 
а пять звезд — что архитектурное свойство является одной из самых сильных сторон архитектурного стиля.

![img.png](../../../img/architecture/n-tier-review.png)

Низкие оценки по тестируемости и развертываемости объясняются высоким риском и сложностью частых деплоев. Простое 
изменение в файле может потребовать регресс всего приложения. Общая надежность имеет среднюю оценку благодаря отсутствию
сетевого трафика.

# Конвейерная архитектура
Данная архитектура так же известна как архитектура каналов и фильтров (pipe & filters). Используется в bash и zsh.

![img.png](../../../img/architecture/pipe_architecture.png)

**Канал** представляет собой однонаправленный способ передачи данных от фильтра к фильтру. **Фильтры** выполняют 
определенные задачи (1 фильтр = 1 задача). Фильтры характеризуются независимостью друг от друга и, как правило, не 
имеют состояния. Всего есть 4 типа фильтров:
1) **Производитель** - источник данных
2) **Преобразователь** (transformer) - принимает входные данные, может выполнять преобразование данных и отправить их 
в канал. Аналог map из функционального программирования
3) **Тестер** (tester) - принимает входные данные, выполняет проверки и на основе проверок может выдать новые данные. Может 
и не выдать. Может и не новые данные, а старые
4) **Потребитель** - конечная точка конвейера. Может, например, сохранять данные в базу, либо что-то отображать 
пользователю.

Конвейерная архитектура применяется в системах с односторонней обработкой данных. Например: преобразование документа из
одного формата в другой, обработка и перемещение данных из одного хранилища в другое, оркестраторы и медиаторы. Apache 
Camel построен на такой архитектуре.

Рассмотрим пример, приложение получает данные из кафки и на основе содержимого сообщений может записать их в MongoDB:

![img.png](../../../img/architecture/pipe_architecture_exmpl.png)

ServiceInfoCapture - фильтр производитель (читает kafka). Duration Filter и Uptime Filter - два фильтра-тестера. Они 
квалифицирует данные и отправляют их в следующий фильтр (duration -> uptime -> завершение). Если данные удовлетворяют
заданным фильтрам, они отправляют их в соответствующие duration calculator и uptime calculator. Это фильтры 
преобразователи, они как-то видоизменяют данные, чтобы их в дальнейшем можно было записать в базу при помощи фильтра
потребителя database output. В этом примере показаны свойства расширяемости архитектуры. После фильтра uptime можно 
добавить еще один или несколько фильтров тестеров. 

![img.png](../../../img/architecture/pipe_review.png)

Сильными сторонами архитектуры конвейерного стиля являются общая стоимость и простота. В монолитной конвейерной 
архитектуре нет сложностей, характерных для распределенных архитектурных стилей. Благодаря выраженной модульности
части системы можно изменять и заменять без какого-либо влияния на другие части системы. Так же благодаря модульности 
у архитектуры неплохие оценки развертываемости и тестируемости. Надежность тоже на уровне из-за отсутствия сетевых 
вызовов. Тем не менее архитектуре свойствены проблемы монолитов, так что эти же параметры (развертываемость, 
тестируемость, надежность) страдают. 

# Микроядерная архитектура
Другое название: архитектура плагинов. Состоит из двух типов компонентов: ядро системы (одно) и множество подключаемых
к нему плагинов. В ядре содержится основная логика приложения, плагины (модули) содержат какую-то дополнительную логику,
которая расширяет возможности ядра. Такой подход обеспечивает расширяемость, адаптируемость и изолированность функций 
приложения. 

Ядро системы формально содержит минимально необходимый функционал для работоспособности системы. Хорошим примером может 
послужить любая IDE - ядро такой системы обычный текстовый редактор. Только при помощи плагинов IDE превращаются в 
полезный продукт. Как правило именно ядро общается с БД, если таковая имеется в системе.

Подключаемые модули независимы друг от друга и содержат функционал, предназначенный для улучшения и расширения ядра. 
Как правило плагины подключаются к ядру как библиотеки. Ядро вызывает плагин посредством простого вызова метода. 
Добавить новые плагины можно прямо в рантайме с помощью dynamic class loading. Второй способ подключения модулей при 
помощи сети. Модули в таком случае вызываются, например, с помощью HTTP REST вызовов. Таким образом можно немного
улучшить масштабируемость, но следует помнить про недостатки сети (и все минусы распределенных систем). 

Микроядерная архитектура применяется во многих инструментальных средствах для разработки ПО (IDE, Jira, Jenkins, etc). 
Другие популярные продукты - браузеры. Если говорить про более бизнесовые сценарии, то допустим, что мы живем в США и
хотим написать приложение для обработки юридических исков. В каждом штате юридические правила разнятся. Если пытаться 
уместить это в одной кодовой базе, то можно легко прийти к большому количеству if. Микроядерная архитектура позволяет
этого избежать. Ядро системы - основные бизнес сценраии обработки юридических исков (принятие, обработка, отправка в 
суд, сопровождение, етс). Каждый подключаемый плагин будет содержать в себе правила обработки исков для конкретного 
штата. 

![img.png](../../../img/architecture/micro-core-architecture.png)

Сильной стороной микроядерной архитектуры является простота и общая стоимость, а слабыми масштабируемость, 
отказоустойчивость. Возможность изоляции функциональности положительно влияют на тестируемость и надежность. Плагины 
положительно влияют на модульность и расширяемость. Неизменный интерес в рамках этой архитектуры вызывает 
масштабируемость. Но как правило приложения, выбравшие данную архитектуру не растут взрывными темпами.

# Архитектура на основе сервисов (service based)
Архитектура на основе сервисов это распределенная архитектура, состоящая из отдельно развернутых крупномодульных 
сервисов и монолитной базой. Каждый сервис независим и делятся по предметным областям. Таким образом каждый сервис это 
какой-то кусок функциональности. Например один сервис может полностью отвечать за заказы, другой за доставку и тд. Данная 
архитектура похожа на микросервисную, об их различиях мы поговорим ниже.

![img.png](../../../img/architecture/service-based-example.png)

Одним из наиболее важных аспектов архитектуры является использование монолитной централизованной базой данных. Это 
позволяет сервисам применять типичные SQL запросы **с поддержкой ACID транзакций**. Небольшое количество сервисов (от 4 
до 12) не создает сложностей с подключениями к базе данных. Такая изюминка позволяет архитектуре обходиться без 
распределенных транзакций. Каждый бизнес процесс использует один сервис, который в свою очередь использует единый 
контекст SQL запроса с единой транзакцией. Данная архитектура соблюдает принципы ACID транзакций лучше, чем любая 
другая распределенная архитектура.

Чтобы лучше понять эту разницу с микросервисной архитектурой, рассмотрим бизнес-запрос по размещению заказа. Это один 
запрос к OrderService, который в свою очередь выполнит: размещение заказа, создание идентификатора заказа, запуск 
механизма оплаты, обновление сведений о складских запасах. Все это в рамках одно сервиса и в рамках единого SQL запроса 
с ACID транзакцией. В рамках микросервисной архитектуры это было бы множество запросов к различным узконаправленным 
микросервисам. Если архитектура на основе сервисов сильно разрастается, то ее могут располовинить. В таком случае могут
появиться распределенные транзакции, но в куда меньшем объеме, чем в микросервисной архитектуре.

![img.png](../../../img/architecture/service-based-review.png)

Архитектура на основе сервисов разбивается по предметному признаку. Каждый сервис является отдельно развернутым
модулем программы. Изменения внесенный в конкретный сервис влияют только на его предметную область, что упрощает 
тестирование. Разбиение на отдельные сервисы позволяет оперативнее вносить изменения (гибкость системы), возможность
более частых развертываний уменьшает связанные с этим риски по сравнению с монолитами. 

Так же в архитектуре высоко оценены отказоустойчивость. Крупные сервисы не обращаются друг к другу, а значит исключается 
сетевое взаимодействие между сервисами и связанные с этим проблемы. Так же если упадет один сервис, то это никак не 
скажется на других сервисах. В целом для более крупных сервисов данной архитектуры харктерен меньший сетевой трафик, 
меньший объем распределенных транзакций и используется меньшая пропускная способность, что увеличивает общую надежность 
архитектуры.

Разумеется существуют гораздо более эффективные стили распределенной архитектуры, но некоторым компаниям это либо 
слишком дорого поддерживать, либо попросту не нужно. 

Наконец, данная архитектура станет удачным выбором, если необходимо достичь высокого уровня архитектурной модульности. 
Как только сервисы приобретают более узкоспециализированный характер, появляются сложность с оркестровкой и 
хореографией, этих минусов лишена рассматриваемая архитектура.