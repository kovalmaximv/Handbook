# Проектирование объектов

1. [Введение в проектирование потокобезопасного класса](#введение-в-проектирование-потокобезопасного-класса)
2. [Ограничение доступа экземпляром](#ограничение-доступа-экземпляром)
3. [Делегирование потокобезопасности](#делегирование-потокобезопасности)
   - [Независимые переменные состояния](#независимые-переменные-состояния)  
4. [Публикация состояния](#публикация-состояния)
5. [Добавление функциональности в существующие потокобезопасные классы](#добавление-функциональности-в-существующие-потокобезопасные-классы)
   - [Блокировка на стороне клиента](#блокировка-на-стороне-клиента)  
   - [Компоновка](#компоновка)  

## Введение в проектирование потокобезопасного класса
Проектирование потокобезопасного класса включает 3 этапа:
1) Определение переменных, формирующий состояние класса
2) Определение инвариантов состояния
3) Создание политики конкурентного доступа к состоянию

Важно понимать ограничения, которые накладываются на состояния объекта. Такие ограничения могут быть вызваны 
бизнес процессами, техническими сложностями и прочими вещами. Понимание таких ограничений необходимы для 
проектирования потокобезопасного класса (в чем мы убедимся ниже).

## Ограничение доступа экземпляром
> :exclamation: **Инкапсуляция данных в объекте ограничивает доступ к ним только методами объекта, что 
> упрощает синхронизацию при помощи замков.**

Пример такого ограничения:
```java
@ThreadSafe
public class PersonSet {
    private final Set<Person> mySet = new HashSet<Person>();
    
    public synchronized void addPerson(Person p) {
        mySet.add(p);
    }
    
    public synchronized boolean containsPerson(Person p) {
        return mySet.contains(p);
    }
}
```
Состояние объекта PersonSet - непотокобезопасный HashSet, но mySet является приватным, не может ускользнуть и 
ограничен одним экземпляром. Единственные ветви кода, которые способны обратиться к mySet защищены внутренним замком. 
Таким образом, класс получился потокобезопасным.

Стоит однако отметить, что если класс Person является мутируемым и непотокобезопасным, то класс перестанет 
быть потокобезопасным.

> :exclamation: **Ограничение доступа экземпляром упрощает создание потокобезопасных классов, так как анализировать 
> приходится один класс, вместо всей программы.**

## Делегирование потокобезопасности
Почти все объекты являются композитными (составными). Если компоненты класса уже потокобезопасны и независимы (не имеют
общих инвариантов), то делегирование потокобезопасности компонентам будет успешным.

#### Независимые переменные состояния
Делегировать потокобезопасность более чем одной переменной состояния возможно, если эти переменные _независимы_. То есть
нет инвариантов с их совместным участием.

Рассмотрим пример с зависимыми переменными:

```java
@NotThreadSafe
public class NumberRange {
    // Инвариант: lower <= upper
    private final AtomicInteger lower = new AtomicInteger(0);
    private final AtomicInteger upper = new AtomicInteger(0);
    
    public void setLower(int num) {
        // Небезопасная операция: проверить и затем действовать
        if (num > upper.get()) {
            throw new RuntimeException();
        }
        lower.set(num);
    }
    
    public void setUpper(int num) {
        // Небезопасная операция: проверить и затем действовать
        if (num < lower.get()) {
            throw new RuntimeException();
        }
        upper.set(num);
    }
}
```
Класс NumberRange не является потокобезопасным: он не соблюдает инвариант `lower <= upper`. Если один поток вызовет 
`setLower(5)`, а другой поток `setUpper(4)`, то из-за операции "проверить и затем действовать" при неудачной временной
координации оба потока пройдут проверку, установят значения и нарушат инвариант. 

В отличие от базовых AtomicInteger компонентный класс непотокобезопасен. Класс NumberRange не может делегировать 
потокобезопасность компонентам, потому что они зависимы.

Данную ситуацию исправит блокировка методов setLower, setUpper.

> :exclamation: **Если класс содержит независимые потокобезопасные переменные и не имеет недопустимых переходов 
> между состояниями, то он может делегировать потокобезопасность своим компонентам.**

## Публикация состояния

> :exclamation: **Если переменная состояния является потокобезопасной, не участвует в инвариантах, ограничивающих ее значение, и не имеет 
> запрещенных переходов из состояния в состояние, то она может быть опубликована**

## Добавление функциональности в существующие потокобезопасные классы
#### Блокировка на стороне клиента
Попробуем добавить атомарный функционал "добавить если отсутствует" в стандартный класс List.

```java
@NotThreadSafe
public class ListHelper<T> {
    public List<T> list = Collections.synchronizedList(new ArrayList<T>());
    
    public synchronized boolean putIfAbsent(T x) {
        boolean absent = !list.contains(x);
        if (absent) {
            list.add(x);
        }
        return absent;
    }
}
```

Почему класс по итогу получился NotThreadSafe? Хоть метод putIfAbsent и синхронизирован, но синхронизация 
происходит на неправильном ключе. Другие операции нашего `list` использует другой ключ, поэтому метод `putIfAbsent` 
не воспринимается другими операциями как атомарный. 

Исправить эту проблему может _блокировка на стороне клиента_. Мы защитим клиентский код, который использует некий 
объект Х, собственным замком объекта Х. Необходимо только узнать, что это за замок, благо большинство 
потокобезопасных коллекций и объектов в документации указывают этот замок.

```java
@ThreadSafe
public class ListHelper<T> {
    public List<T> list = Collections.synchronizedList(new ArrayList<T>());
    
    public boolean putIfAbsent(T x) {
        synchronized (list) {
            boolean absent = !list.contains(x);
            if (absent) {
                list.add(x);
            }
            return absent; 
        }
    }
}
```

#### Компоновка
Так же добавить атомарную операцию в существующий класс поможет _компоновка_. Пример ниже использует этот подход:
```java
@ThreadSafe
public class ImprovedList<T> implements List<T> {
    private final List<T> list;
    
    public ImprovedList(List<T> list) { this.list = list; }
    
    public synchronized boolean putIfAbsent(T x) {
        boolean absent = !list.contains(x);
        if (absent) {
            list.add(x);
        }
        return absent;
    }
    
    public synchronized void clear() {
        // ... делегировать остальные методы схожим образом
    }
}
```