# Предотвращение сбоев жизнеспособности
## Взаимная блокировка (deadlock)
Взаимная блокировка возможна при следующем случае:
1) Поток А владеет бессрочно замком А1
2) Поток В владеет бессрочно замком В1
3) Поток А пытается приобрести замок В1, получает блокировку
4) Поток В пытается приобрести замок А1, получает блокировку

Таким образом, оба потока будут вечно ждать друг друга, поскольку ни один поток не освободит замок, необходимый 
другому потоку и оба потока будут вечно заблокированы. JVM никак не решает данную ситуацию, заблокированные потоки 
останутся таковыми навсегда. Работоспособность приложения может восстановить только перезапуск приложения. 

#### Взаимные блокировки из-за порядка блокировки
Рассмотрим пример:
```java
public class LeftRightDeadLock {
    private final Object leftObject;
    private final Object rightObject;
    
    public void leftRight() {
        synchronized (leftObject) {
            synchronized (rightObject) {
                doSomething();
            }
        }
    }
    
    public void rightLeft() {
        synchronized (rightObject) {
            synchronized (leftObject) {
                doSomething();
            }
        }
    }
}
```
Оба метода приобретают левый и правый замки, в случае неудачной временной координации два потока могут 
заблокироваться следующим образом:
![deadlock_example](../../../../img/multithread/deadlock_example.jpg)

Взаимная блокировка возникла, потому что два потока приобретали одинаковые замки в _разном порядке_. Если обеспечить, 
чтобы все потоки приобретали одинаковые замки в одинаковом порядке, то такую проблему можно избежать.

> :exclamation: **Чтобы избавиться от взаимной блокировки, возникающей из-за порядка блокировки, необходимо чтобы 
> все потоки приобретали замки в фиксированном глобальном порядке.**

#### Взаимные блокировки из-за динамического порядка следования замков
В некоторых случаях мы не владеем порядком блокировки, в таких случаях возникает динамический порядок 
следования замков. Рассмотрим пример:
```java
public void transferMoney(Account fromAccount, Account toAccount) {
    synchronized(fromAccount) {
        synchronized(toAccount) {
            fromAccount.debit(300);
            toAccount.credit(300);
        }
    }
}
```
Может показаться, что все потоки приобретают замки в одном и том же порядке. На самом деле порядок следования замков 
динамичный и зависит от передаваемых аргументов. Блокировка может возникнуть, если два потока одновременно вызывают 
метод, один переводит деньги `X -> Y`, а другой переводит деньги `Y -> X`. При неудачной координации поток А 
приобретает замок на аккаунт Х и будет ожидать замок на аккаунт Y, в то время как поток В приобретает замок 
на аккаунт Y и будет ожидать замок на аккаунт X.

От взаимных блокировок подобного рода можно избавиться, если закрепить порядок блокировки для объектов. Самый простой 
способ, использовать некоторый идентификатор объекта. В нашем случае подошел бы `account.id`. Порядок приобретения 
замков тогда можно было бы определить как от большего ключа к меньшему.

Если у объекта нет идентификатора, можно использовать `System.identityHashCode`. По численному значения хеша 
можно определить порядок приобретения блокировок. Важно учесть случай, когда объекты имеют одинаковый хеш код, в 
таких случаях можно сначала приобрести замок на некоторый сторонний объект. Пример данного подхода:
```java
private static final Object tieLock;

public void transferMoney(Account fromAccount, Account toAccount) {
    int fromHash = System.identityHashCode(fromAccoutn);
    int toHash = System.identityHashCode(toAccoutn);
    
    if (fromHash < toHash) {
        synchronized (fromAccount) {
            synchronized(toAccount) {
                // transfer money
            }
        }
    } else if (toHash < fromHash) {
        synchronized(toAccount) {
            synchronized(fromAccount) {
                // transfer money
            }
        }
    } else {
        synchronized(tieLock) {
            synchronized (fromAccount) {
                synchronized(toAccount) {
                    // transfer money
                }
            }
        }
    }
}
```

#### Взаимные блокировки между взаимодействующими методами
Вложенное замковое приобретение не всегда так очевидно, как в предыдущих примерах, два замка не обязательно будут 
приобретены в рамках одного метода или даже в рамках одного объекта. 

Обнаружить возможность такой взаимной блокировки сложнее. Предупреждающим признаком является то, что _чужой_ метод 
вызывается, пока замок удерживается.

> :exclamation: **Активировать чужой метод с удержанием замка - плохая затея. Чужой метод может приобретать другие 
> замки (рискуя быть запертым взаимной блокировкой) или выполняться неожиданно долго, удерживая при этом замок.** 

#### Открытые вызовы
Вызов чужого метода с удержанием замка трудно анализируется на предмет взаимных блокировок, а значит, 
является рискованным.

Вызов метода без удерживаемых замков называется открытым вызовом (open call). Классы, опирающиеся на открытые вызовы
являются более благополучными и композиционно пригодными к конкурентному выполнению. Нужно стремиться к такому 
проектированию системы, которое использовало бы только открытые вызовы.

Уменьшение синхронизированных блоков позволяет достигнуть открытых вызовов. Однако таким образом страдает 
атомарность кода. Иногда потеря атомарности критична. В таких случаях используют техническое решение, 
при котором **только один** поток может выполнять код после открытого вызова. Решение состоит в том, чтобы внутренним 
состоянием сервиса обозначить, что сервис недоступен для выполнения другим потокам.

#### Ресурсные взаимные блокировки
Ресурсные взаимные блокировки возможны при малом пуле ресурсов. Возможна эта блокировка в следующем случае:
1) Есть пул из двух соединений к двум разным БД.
2) Поток А удерживает соединение D1 из пула соединений.
3) Поток B удерживает соединение D2 из пула соединений.
4) Потоку А необходимо подключение D2 из пула соединений.
5) Потоку B необходимо подключение D1 из пула соединений.

В таком случае потоки А и B так же будут взаимно заблокированы по причине нехватки ресурсов (соединений к БД). При 
увеличении пула ресурсов такие проблемы, как правило, решаются.

Так же существует **взаимная блокировка с ресурсным голоданием**. Простейший пример возникновение такой блокировки:
1) Есть пул потоков из 1 потока.
2) В этом пуле выполняется зависимая задача, которая ожидает результат выполнения следующей задачи из рабочей очереди.

В таком случае задача будет ожидать вечно, так как свободных потоков для выполнения следующей задачи нет. 

Зависимые задачи в ограниченном пуле являются первичным источником взаимной блокировки с ресурсным голоданием.

## Предотвращение и диагностирование взаимной блокировки
Прежде всего, если ваша программа не приобретает более одного замка за раз, то взаимная блокировка ей не грозит, 
анализ можно не проводить. Взаимная блокировка такой программе не грозит.

В большинстве случаев ваш код будет приобретать более одного замка за раз. В таком случае, порядок приобретения замков 
должен стать частью проекта. Опишите протокол порядка приобретения замков в своем проекте.

#### Хронометрированные замки
Хронометрированные версии замков помогут обнаружить и восстановиться после взаимной блокировки.

Необходимо использовать хронометрированную версию приобретения замка с указанием времени, которого точно должно хватить
на выполнение операции. 

Когда попытка с хронометрированным замком провалилась, вы не обязательно узнаете точную причину проблемы. Возможно 
это была взаимная блокировка, возможно поток ошибочно вошел в бесконечный цикл, etc. Тем не менее, отлавливая ошибку, 
вы можете сохранить всю интересующую информацию и предпринять шаги к восстановлению.

#### Поточные дампы JVM
JVM также предоставляет инструмент для диагностики взаимных блокировок. Поточный дамп содержит трассировку для 
каждого работающего потока (подобно трассировке при исключениях). Поточные дампы так же содержат много полезной 
информации о работе замков.

При запуске генерации поточного дампа, JVM пытается найти активные взаимные блокировки. Если JVM такие нашла, то включит
информацию о них в отчет.

## Другие сбои жизнеспособности
Хоть взаимная блокировка и является самой встречаемой причиной сбоя многопоточных программ, есть и другие проблемы
жизнеспособности.

#### Голодание
Голодание происходит, когда поток постоянно лишается необходимых ресурсов (процессорные циклы, коннекты к БД, 
замки, etc). Если проблема не в количестве ресурсов, то она кроется в поточных приоритетах или 
неоптимизированных потоках.

В случае проблем с процессорными циклами существует API поточных приоритетов. Однако не стоит вмешиваться в работу ОС и 
процессора. Как правило, ничего хорошего из этого не выходит.

#### Активная блокировка
Активная блокировка (livelock) - форма сбоя жизнеспособности, когда поток не заблокирован, но все равно не может 
продвигаться по выполнению. Например, по причине неудачных транзакций, бесконечных циклов, etc. 

Такая форма активной блокировки обычно случается от избыточного кода обработки исключений. Такой код ошибочно пытается
исправить ошибку, которую невозможно исправить.

# Итоги
- Сбои жизнеспособности представляют большую угрозу, поскольку нет способов восстановления, кроме прерывания приложения.
- Самой частой причиной сбоя жизнеспособности является взаимная блокировка. 
- Проблем взаимной блокировки в противоречивом приобретении нескольких замков несколькими потоками. 
- Решение взаимной блокировки в обеспечении порядка приобретения нескольких замков на уровне приложения. 
- Первый шаг к исключению проблем: использование открытых вызовов. Это значительно уменьшает количество мест, где 
удерживаются сразу несколько замков. Также облегчает анализ кода, при поиске таких мест. 