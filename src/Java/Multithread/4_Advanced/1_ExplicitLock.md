[Назад](README.md)
# Явные замки

1. [Lock и ReentrantLock](#Lock-и-ReentrantLock)  
   1.1. [Опрашиваемое и хронометрируемое приобретение замка](#Опрашиваемое-и-хронометрируемое-приобретение-замка)  
   1.2. [Прерываемое приобретение замка](#Прерываемое-приобретение-замка)  
   1.3. [Соображения по поводу производительности](#Соображения-по-поводу-производительности)  
2. [Справедливость (Fairness)](#Справедливость-(Fairness))
3. [Выбор между synchronized и ReentrantLock](#Выбор-между-synchronized-и-ReentrantLock)
4. [Замки чтения-записи](#Замки-чтения-записи)
5. [Итоги](#Итоги)

Помимо synchronized в Java есть механизм явных замков. Самый часто используемый - ReentrantLock. Данный замок 
используется тогда, когда функционала внутренних замков не хватает.

## Lock и ReentrantLock
Lock - общий интерфейс для всех явных замков. В отличие от внутренних замков, Lock предлагает выбор между безусловным, 
опрашиваемым, хронометрированным и прерываемым замковым приобретением. 

Повторно входимый ReentrantLock обеспечивает те же гарантии и семантику, что и synchronized. Однако ReentrantLock 
обеспечивает бОльшую гибкость для работы с замками.

Зачем необходимы явные замки, когда есть механизм внутренних замков? Внутренняя замковая защита ограничена в 
функциональности. Например, она не может прервать ожидание замка или попытаться приобрести замок, не желая ждать вечно.
Внутренние замки так же должны освобождаться в том же блоке кода, в котором они приобретены. 

В примере ниже представлена стандартная форма использования явного замка Lock. Стоит обратить внимание, что замок
_должен_ быть освобожден в блоке finally.

```java
Lock lock = new ReentrantLock();
//...
lock.lock();
try {
    // Произвести необходимые действия.
    // Отловить исключения при необходимости.
} finally {
    lock.unlock();
}
```

#### Опрашиваемое и хронометрируемое приобретение замка
Метод Lock.tryLock позволяет реализовать хронометрированное и опрашиваемое приобретение замка. Благодаря этому, можно
избежать фатальности при взаимной блокировке.

Метод Lock.tryLock сразу приобретает замок и возвращает true, если это возможно. Иначе сразу возвращает false, без 
приобретения замка. Есть хронометрированная версия, в которой указывается, сколько времени ждать в попытках приобрести 
замок.

Пример такого приобретения:
```java
public void getLock(Lock lock, Long sleepDelay) {
    while (true) {
        if (lock.tryLock()) {
            try {
                // Do something
            } finally {
                lock.unlock();
            }   
        }
        Thread.sleep(sleepDelay);
    }
}
```

При помощи такого приобретения замка можно с легкостью избежать взаимной блокировки из-за порядка приобретения. Если
один из замков приобрести получилось, а второй нет, то первый замок можно отпустить. 

#### Прерываемое приобретение замка
Метод Lock.lockInterruptibly пытается приобрести замок до тех пор, пока текущий поток не прерывается. Данный метод
пробрасывает InterruptedException, поэтому для его использования нужны два блока try-catch. 

Стандартное использование lockInterruptibly:
```java
public boolean lockInterruptiblyExample() throws InterruptedException {
    lock.lockInterruptibly();
    try {
        // Do something
    } finally {
        lock.unlock();
    }
}
```

Стоит помнить, что хронометрированная версия tryLock тоже откликается на прерывание.

## Соображения по поводу производительности
В java 5 явные замки были быстрее внутренних при частом блокировании. Однако начиная в Java 6 внутренние 
замки оптимизировали. На данный момент явные замки немного быстрее внутренних замков. Однако эта разница несущественна.

## Справедливость (Fairness)
Конструктор ReentrantLock представляет выбор из двух режимов: несправедливый (по умолчанию) и справедливый. 

Потоки приобретают справедливый замок в том порядке, в котором они его запрашивали. Несправедливый замок использует 
механизм проталкивания. Запрашивающие замок потоки могут перепрыгивать вперед очереди, если замок оказался свободным 
при обращении. Со справедливым замком запросивший его поток всегда становится в очередь (если замок не свободен), 
с несправедливым только если замок в настоящее время занят.

> :exclamation: **Lock.tryLock всегда проталкивает потоки, даже для справедливых замков.**

Почему несправедливый замок используется по умолчанию и чем он лучше? Справедливость имеет значительную стоимость для 
производительности из-за издержек на приостановку и возобновление потоков. К тому же, запрашивающий поток может 
закончить работу быстрее, чем поток из очереди будет ждать разблокировку.

На практике, несправедливые замки предоставляют гарантию, что блокированный поток в конце концов получит замок и этого 
вполне хватает. Производительность несправедливых замков перевешивает преимущества справедливой очередности.

Справедливые замки лучше всего работают в течение длительного времени, когда время между замковыми запросами велико. 
Однако штраф к производительности у справедливого замка ощутим. _Не платите за справедливость, если она вам не нужна_.

Внутренний замок так же **не дает** гарантий справедливости. Спецификация Java не требует, чтобы внутренние замки были 
справедливыми и никакие производственные JVM этого не делают.

## Выбор между synchronized и ReentrantLock
ReentrantLock предоставляет дополнительную функциональность без штрафа к производительности. Однако их использование 
больше подвержено ошибкам. Если забыть в блоке finally освободить замок, он не освободится никогда. 

В то же время внутренние замки имеют знакомую и компактную форму записи, почти все существующие программы зачастую
используют внутренние замки. Не получится совершить явных ошибок при использовании внутренних замков (они освобождаются
автоматически). К тому же потоковые дампы JVM умеют работать с внутренними замками, а с внешними нет.

> :exclamation: **Используйте явные замки, если вам необходим функционал, который отсутствует во внутренних замках. 
> В иных случаях отдайте предпочтение внутренним замкам.**


## Замки чтения-записи
Все рассмотренные нами замки до этого времени поддерживали взаимную блокировку, владеть замком мог лишь один поток. 
Замки чтения-записи доступны многочисленным читателям либо единственному писателю за раз, но не обоим одновременно.

Интерфейс ReadWriteLock:
```java
public interface ReadWriteLock {
    Lock readLock();
    Lock writeLock();
}
```

На практике замки чтения-записи повышают производительность часто используемых структур данных с преобладающим чтением 
без модификации.

Стандартная реализация замка чтения-записи ReentrantReadWriteLock. В случае справедливого замка предпочтение отдается
потоку, который дольше всех ждал. Если замком владеют читатели и поток запрашивает писатель, то ни одному читателю 
больше не разрешается приобретать замок чтения до тех пор, пока писатель не будет обслужен и не освободит замок. 

В случае несправедливого замка порядок не определен. Разрешается понижение с писателя до читателя, обратное понижение 
не разрешается.

# Итоги
- Явные замки предлагают расширенный функционал без потери производительности.
- Тем не менее явные замки имеют не такой удобный синтаксис и больше подвержены ошибкам использования.
- Используйте явные замки, только если вам необходим функционал, который не предоставляют внутренние замки.
- Замки чтения-записи доступны многочисленным писателям, либо единственному писателю, но не одновременно.