# Чистый код
Конспект книги Боба Мартина "Чистый код". Комментарии от себя буду оставлять в квадратных скобках.

## Нейминг
Имя переменной, функции или класса должно отвечать на все главные вопросы. Оно должно сообщить, почему эта переменная
существует, что она делает и как используется. Если имя требует дополнительных комментариев, значит оно не передает 
намерений программиста.

Оставляйте имена интерфейсов без префиксов и постфиксов. То есть интерфейс должен называться ShapeFactory, а не 
IShapeFactory. Префикс отвлекает и передает лишнюю информацию, пользователь не должен знать, что имеет дело с 
интерфейсом. Реализацию интерфейса можно отобразить, например ShapeFactoryImpl, чтобы не путать с интерфейсом.

Имена классов и объектов должны представлять собой существительные и их комбинации. Имена методов представляют собой 
глаголы и глагольные словосочетания.

## Функции
Функции должны быть компактны. Желательный объем функции не превышает 20 строк. Чем меньше функция, тем проще выбрать 
для нее хорошее имя. Чем меньше аргументов у функции, тем лучше. Если аргументов много - выносите в объекты или 
переменные класса (которая владеет функцией). Не стоит использовать выходные аргументы, это аргументы которые изменяет 
функция и они являются результатом ее работы. Если функция все-таки изменяет аргумент, то лучше вернуть его экземпляр, 
то есть вместо `void transform(StringBuffer sb)` лучше использовать `StringBuffer transform(StringBuffer sb)`.

Строго избегайте дублирования кода. Дублирование означает, что вы не до конца поняли какую-то концепцию, которую можно 
объединить в единую функцию.

Если для понимания функции необходимо смотреть ее сигнатуру, то такую функцию следует переписать.

Нельзя использовать аргументы флаги в функциях. Такой аргумент усложняет сигнатуру и сразу говорит нам о том, что 
функция будет выполнять две операции. При одном значении флага следует использовать одну функцию, при другом другую.

Блоки в командах if/else/while и т.д. должны состоять из одной строки, в которой содержится вызов функции. Это не только
делает функции более компактными, но и способствует документированию кода, поскольку функции можно присвоить 
содержательное имя. Максимальный уровень отступа в функциях не превышает одного-двух, все остальное следует выносить в 
другие функции с содержательными именами. Это упрощает чтение и понимание функций.

Функция должна выполнять одну операцию и делать ее хорошо. Если функция выполняет действия одного уровня отступа, то как
правило такая функция выполняет одну операцию. Так же следует постоянно спрашивать себя "могу ли я извлечь из этой 
функции функцию поменьше". Так же следует проверять уровень абстракции внутри функции. Если в рамках одной функции вы 
выполняете бизнес код, читаете файл и занимаетесь парсингом спец символов из текста, ты вы смешали в одной функции 
3 уровня абстракции и такую функцию надо разбить. Смешение уровней абстракций создает путаницу.

Если ваша функция обещает делать одно, но делает что-то другое _скрытое от пользователя_, то это абсолютное зло. Такие 
функции, например, могут неожиданно менять значение переменных класса или аргументов. Следует четко указывать в 
наименовании функции, что она будет делать.

Необходимо по возможности избавляться от switch конструкций и реализовывать полиморфизм. Switch допустим только в 
фабриках, которые будут помогать создавать полиморфные объекты, чтобы скрываться от остальной части системы. Например:

```java
public Money calculateMoney(Employee e) {
    switch (e.getType()) {
        case COMISSION:
            return calculateCommissionMoney();
        case HOURLY:
            return calculateHourlyMoney();
        case SALARIED:
            return calculateSalariedMoney();
        default:
            throw new InvalidArgumentException();
    }
}
```

Такая функция большая и при появлении новых типов будет разрастаться. Она выполняет больше одной операции. Нарушает 
принцип единственной ответственности. Нарушает принцип открытости/закрытости. Ну и самое главное, программа может
содержать бесчисленное множество похожих функций, например `isPayday(Employee e, Date date)` или 
`deliverPay(Employee e, Money pay)`. Решение заключается в том, чтобы использовать абстрактную фабрику:

```java
public abstract class Employee {
    public abstract boolean isPayday();
    public abstract Money calculatePay();
    public abstract void deliverPay();
}
// ---
public interface EmployeeFactory {
    Employee maleEmployee(EmployeeRecord record);
}
// ---
public class EmployeeFactoryImpl implements EmployeeFactory {
    public Employee makeEmployee(EmployeeRecord record) {
        switch (record.type) {
            case COMMISSIONED: 
                return new CommissionEmployee();
            case HOURLY:
                return new HourlyEmployee();
            case SALARIED:
                return new SalariedEmployee();
            default:
                throw new InvalidArgumentException();
        }
    }
}
```

Блоки try/catch выглядит уродливо. Они запутывают структуру и смешивают обработку ошибок с нормальной обработкой. По
этой причине следует выделять try-catch в отдельные функции. Функция, обрабатывающая ошибки, больше не должна ничего 
делать:
```java
public void delete(Arguments args) {
    try {
        deletePageAndAllReference(args);
    } catch (Exception e) {
        logError(e);
    }
}
```

## Комментарии
Не комментируйте плохой код - перепишите его.

Комментарий - всегда признак неудачи. Мы вынуждены использовать комментарии, потому что мы не всегда можем выразить свои
мысли без них. Если вы хотите написать комментарий остановитесь и подумайте, можете ли вы переписать код так, чтобы 
комментарий не был нужен.

Чем плохи комментарии? Чем древнее комментарий и чем он дальше расположен от выполняемого кода, тем больше вероятность, 
что он просто неверен. Вполне вероятно, что с очередным изменением кода забыли поправить комментарий. 

Пример:
```java
// Проверить, положена ли сотруднику зарплата
if ((employee.flags & HOURLY_FLAG) && employee.age > 65) { ... }

if (employee.isEligibleFullBenefits()) { ... }
```

Примеры хороших комментариев:
- Информативные комментарии: некоторые конструкции языка, например Regex довольно тяжело описать одним языком 
программирования. В таком случае иногда можно оставить комментарий с примером.
- Представление намерений: некоторые решения могут быть неочевидны другим людям. Чтобы пояснить, что это не ошибка и не 
надо это дорабатывать, иногда лучше оставить комментарий.
- Предупреждение о последствиях: некоторые технические решения могут доставить проблемы, если не знать как правильно с 
ними взаимодействовать. Например, различные многопоточные инструменты требуют особого подхода, о таком можно 
предупредить в комментарии.
- Комментарии ToDo: если сейчас что-то сделать что-то сейчас невозможно и необходимо сделать это позже. 
- Усиление: некоторые решения могут казаться неважными, которые можно опустить при рефакторинге. Иногда стоит 
подсветить такие решения.

Примеры плохих комментариев: 
- Бормотание: не стоит писать комментарии на скорую руку. Раз уж вы это начали, пишите хороший комментарий
- Избыточные: если по коду и так все ясно, не стоит дописывать к нему комментарии
- Недостоверные: если комментарий будет несоответствовать коду, следующий разработчик будет сильно негодовать
- Шум: комментарии указывающие на очевидные вещи или названия полей класса
- Не используйте комментарии там, где можно использовать функцию или переменную

## Форматирование
Мы хотим, чтобы читатель нашего кода был поражен нашей аккуратностью, логичностью и вниманием к мелочам. Мы хотим, чтобы
на него произвело впечатление стройность кода. Мы хотим, чтобы он уважительно поднял бровь при просмотре модулей. Мы 
хотим, чтобы наша работа выглядела профессионально. 

Переменные следует объявлять как можно ближе к месту применения. Если функция очень короткая, ее локальные переменные
стоит объявить в самом начале.

Если одна функция вызывает другую, они должны располагаться вблизи друг от друга. В идеале вызывающая функция над 
вызываемой.

## Объекты и структуры данных
Существует веская причина для ограничения доступа к переменным объектов: мы не хотим, чтобы другие программисты 
зависели от них. Мы хотим свободно менять типы или реализацию этих переменных и чтобы другие программисты этого даже
не заметили. Сокрытие реализации не сводится к предоставлению методов доступа к приватным параметрам объекта. Вместо 
этого мы должны предоставлять абстрактные интерфейсы для работы с объектом, не раскрывая его внутреннее устройство. 
Если оставить состояние объекта открытым, то оно утечет в пользовательский код и каждое изменение деталей вашего объекта 
может стать проблемой для других программистов.

Плохой пример сокрытия реализации. Мы знаем даже точные типы данных, которые использует объект. Нам предлагается самим
работать с этим объектом:
```java
public interface Vehicle {
    double getFuelTankCapacity();
    double getCurrentGallons();
}
```
Пример получше, мы не знаем реализацию объекта и имеем необходимые методы работы с этой сущностью:
```java
public interface Vehicle {
    double getPercentFuelRemaining();
}
```

Проблема не решается бездумным использованием интерфейсов или методов чтения/записи. Чтобы найти лучший способ 
реализации объекта, необходимо серьезно поразмыслить.

Выясним разницу между структурой и объектами. Структуры раскрывают свои данные и не имеют осмысленных функций. Объекты
скрывают свои данные и предоставляют функции, работающие с этими данными. Код, использующий структуры данных, усложняет
добавления новых структур данных, потому что придется дописывать все функции, работающие с зоопарком таких структур.
Объектно-ориентированный код усложняет добавление новых функций, потому что в таком случае надо будет дописывать всех
наследников интерфейса. Отсюда следует, что не стоит представлять все в виде в виде объектов. Иногда предпочтительнее 
обычные структуры данных и процедуры работающих с ними. [В качестве процедур Боб предлагает функции с instance of. Я не 
уверен, что это хорошая идея.]

## Обработка ошибок
Из-за разбросанной повсюду обработки ошибки практически невозможно понять, что делает код. Обработка ошибок важна, 
но если она заслоняет собой логику программы - значит она реализована неверно. 

_Используйте непроверяемые исключения._ По прошествию лет стало понятно, что проверяемые исключения неудобны в 
использовании. Если вы выбрасываете проверяемое исключение, а обработка это исключения находится тремя уровнями выше, то 
это исключение должно быть объявлено в сигнатуре всех методов между выбрасываемым и обрабатываемом исключение. Представьте
иерархию вызовов большой системы, допустим, что одна из функций низкого уровня изменилась и начала выбрасывать 
проверяемое исключение. Мы получим каскад изменений сигнатур функций в половине системы, изменения с низкого уровня 
потянули изменения верхнего уровня. 

Проверяемые исключения могут пригодиться при написании особо важных библиотек, когда программист _обязан_ перехватить 
исключение. Но в общем случае должно быть достаточно непроверяемых исключений.

Создавайте содержательные сообщения об ошибках. Так же хорошо сопровождать исключение логированием более технической 
информации об ошибке.

Зачастую в проектируемой области кода достаточно одного класса ошибок. Информация, передаваемая с исключением, поможет
различать различные виды ошибок. Используйте различные классы ошибок только если вы намерены разрешить перехватывать 
одни исключения и пропускать другие. 

Не возвращайте null, используйте Optional, если функция способна ничего не вернуть. Это поможет избавиться от 
бесконечных проверок на null. Так же не передавайте null в аргументы функции, если в аргументы функции передается null, 
это сигнализирует о существующей проблеме (либо с ней еще предстоит столкнуться).

## Границы
Если в вашем коде используются сторонние библиотеки, позаботьтесь о том, чтобы будущие изменения данной библиотеки не 
обходились слишком дорого. Для этого необходимо свести к минимуму прямой вызов сторонних библиотек, с этим может помочь 
паттерн адаптер. В данном паттерне мы инкапсулируем обращение со сторонней библиотекой, а в коде везде используется наш
адаптер. Таким образом при изменении библиотеки нужно будет править только одно место в коде.