# Чистый код
Конспект книги Боба Мартина "Чистый код". Комментарии от себя буду оставлять в квадратных скобках.

## Нейминг
Имя переменной, функции или класса должно отвечать на все главные вопросы. Оно должно сообщить, почему эта переменная
существует, что она делает и как используется. Если имя требует дополнительных комментариев, значит оно не передает 
намерений программиста.

Оставляйте имена интерфейсов без префиксов и постфиксов. То есть интерфейс должен называться ShapeFactory, а не 
IShapeFactory. Префикс отвлекает и передает лишнюю информацию, пользователь не должен знать, что имеет дело с 
интерфейсом. Реализацию интерфейса можно отобразить, например ShapeFactoryImpl, чтобы не путать с интерфейсом.

Имена классов и объектов должны представлять собой существительные и их комбинации. Имена методов представляют собой 
глаголы и глагольные словосочетания.

## Функции
Функции должны быть компактны. Желательный объем функции не превышает 20 строк. Чем меньше функция, тем проще выбрать 
для нее хорошее имя. Чем меньше аргументов у функции, тем лучше. Если аргументов много - выносите в объекты или 
переменные класса (которая владеет функцией). Не стоит использовать выходные аргументы, это аргументы которые изменяет 
функция и они являются результатом ее работы. Если функция все-таки изменяет аргумент, то лучше вернуть его экземпляр, 
то есть вместо `void transform(StringBuffer sb)` лучше использовать `StringBuffer transform(StringBuffer sb)`.

Строго избегайте дублирования кода. Дублирование означает, что вы не до конца поняли какую-то концепцию, которую можно 
объединить в единую функцию.

Если для понимания функции необходимо смотреть ее сигнатуру, то такую функцию следует переписать.

Нельзя использовать аргументы флаги в функциях. Такой аргумент усложняет сигнатуру и сразу говорит нам о том, что 
функция будет выполнять две операции. При одном значении флага следует использовать одну функцию, при другом другую.

Блоки в командах if/else/while и т.д. должны состоять из одной строки, в которой содержится вызов функции. Это не только
делает функции более компактными, но и способствует документированию кода, поскольку функции можно присвоить 
содержательное имя. Максимальный уровень отступа в функциях не превышает одного-двух, все остальное следует выносить в 
другие функции с содержательными именами. Это упрощает чтение и понимание функций.

Функция должна выполнять одну операцию и делать ее хорошо. Если функция выполняет действия одного уровня отступа, то как
правило такая функция выполняет одну операцию. Так же следует постоянно спрашивать себя "могу ли я извлечь из этой 
функции функцию поменьше". Так же следует проверять уровень абстракции внутри функции. Если в рамках одной функции вы 
выполняете бизнес код, читаете файл и занимаетесь парсингом спец символов из текста, ты вы смешали в одной функции 
3 уровня абстракции и такую функцию надо разбить. Смешение уровней абстракций создает путаницу.

Если ваша функция обещает делать одно, но делает что-то другое _скрытое от пользователя_, то это абсолютное зло. Такие 
функции, например, могут неожиданно менять значение переменных класса или аргументов. Следует четко указывать в 
наименовании функции, что она будет делать.

Необходимо по возможности избавляться от switch конструкций и реализовывать полиморфизм. Switch допустим только в 
фабриках, которые будут помогать создавать полиморфные объекты, чтобы скрываться от остальной части системы. Например:

```java
public Money calculateMoney(Employee e) {
    switch (e.getType()) {
        case COMISSION:
            return calculateCommissionMoney();
        case HOURLY:
            return calculateHourlyMoney();
        case SALARIED:
            return calculateSalariedMoney();
        default:
            throw new InvalidArgumentException();
    }
}
```

Такая функция большая и при появлении новых типов будет разрастаться. Она выполняет больше одной операции. Нарушает 
принцип единственной ответственности. Нарушает принцип открытости/закрытости. Ну и самое главное, программа может
содержать бесчисленное множество похожих функций, например `isPayday(Employee e, Date date)` или 
`deliverPay(Employee e, Money pay)`. Решение заключается в том, чтобы использовать абстрактную фабрику:

```java
public abstract class Employee {
    public abstract boolean isPayday();
    public abstract Money calculatePay();
    public abstract void deliverPay();
}
// ---
public interface EmployeeFactory {
    Employee maleEmployee(EmployeeRecord record);
}
// ---
public class EmployeeFactoryImpl implements EmployeeFactory {
    public Employee makeEmployee(EmployeeRecord record) {
        switch (record.type) {
            case COMMISSIONED: 
                return new CommissionEmployee();
            case HOURLY:
                return new HourlyEmployee();
            case SALARIED:
                return new SalariedEmployee();
            default:
                throw new InvalidArgumentException();
        }
    }
}
```

Блоки try/catch выглядит уродливо. Они запутывают структуру и смешивают обработку ошибок с нормальной обработкой. По
этой причине следует выделять try-catch в отдельные функции. Функция, обрабатывающая ошибки, больше не должна ничего 
делать:
```java
public void delete(Arguments args) {
    try {
        deletePageAndAllReference(args);
    } catch (Exception e) {
        logError(e);
    }
}
```

## Комментарии
Не комментируйте плохой код - перепишите его.

Комментарий - всегда признак неудачи. Мы вынуждены использовать комментарии, потому что мы не всегда можем выразить свои
мысли без них. Если вы хотите написать комментарий остановитесь и подумайте, можете ли вы переписать код так, чтобы 
комментарий не был нужен.

Чем плохи комментарии? Чем древнее комментарий и чем он дальше расположен от выполняемого кода, тем больше вероятность, 
что он просто неверен. Вполне вероятно, что с очередным изменением кода забыли поправить комментарий. 

Пример:
```java
// Проверить, положена ли сотруднику зарплата
if ((employee.flags & HOURLY_FLAG) && employee.age > 65) { ... }

if (employee.isEligibleFullBenefits()) { ... }
```

Примеры хороших комментариев:
- Информативные комментарии: некоторые конструкции языка, например Regex довольно тяжело описать одним языком 
программирования. В таком случае иногда можно оставить комментарий с примером.
- Представление намерений: некоторые решения могут быть неочевидны другим людям. Чтобы пояснить, что это не ошибка и не 
надо это дорабатывать, иногда лучше оставить комментарий.
- Предупреждение о последствиях: некоторые технические решения могут доставить проблемы, если не знать как правильно с 
ними взаимодействовать. Например, различные многопоточные инструменты требуют особого подхода, о таком можно 
предупредить в комментарии.
- Комментарии ToDo: если сейчас что-то сделать что-то сейчас невозможно и необходимо сделать это позже. 
- Усиление: некоторые решения могут казаться неважными, которые можно опустить при рефакторинге. Иногда стоит 
подсветить такие решения.
- 