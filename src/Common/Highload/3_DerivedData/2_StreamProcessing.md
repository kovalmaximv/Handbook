# Потоковая обработка
Данные для пакетной обработки конечны и ограничены по размеру. В реальной жизни так происходит далеко не всегда, 
зачастую данные просто генерируются пользователем неограниченное время. Такой поток данных можно обрабатывать пакетным
образом, например дискретно каждый день/час/минуту. Но в таком случае пользователи увидят итог своих действий не сразу, 
а тогда, как в следующий раз сработает пакетная обработка. Для решения такой проблемы существует _потоковая обработка_
данных. В этом случае поток данных слушается на постоянной основе и свежепоступившие события обрабатываются сразу (в
порядке очереди, если обработчик не успевает).

## Передача потоков событий
В потоковой обработке вместо файлов используются _события_. Это может быть что угодно: действие пользователя, замеры 
датчиков, результаты наблюдений, етс. События могут представлять из себя что угодно: JSON строки, просто строки, 
бинарные данные, етс. События генерируют _инициатором_ (издатель/отправитель), а затем обрабатываются разными 
потребителями (подписчиками/получателями). Взаимосвязанные события объединяются в _тему_ или _поток_.

Что делать, когда инициатор поставил новое событие? Потребители могут сами опрашивать инициатора раз в какое-то время,
но это добавляет накладные расходы (особенно если делать проверки часто). Вместо этого лучше отправлять потребителям
уведомления о появлении новых событий. Традиционные БД не предназначены для поддержки такого механизма. Вместо этого для
доставки событий были разработаны специальные инструменты.

Общий принцип уведомления пользователя заключается в использовании **системы обмена сообщениями (messaging system)**:
инициатор отправляет сообщение в систему, а она затем рассылает его всем потребителям.

Системы обмена сообщениями используют широкий спектр подходов, единой технологии на все случаи жизни не существует. Для
классификации этих систем можно задать себе следующие вопросы:
1) Что произойдет, если инициаторы будут отправлять сообщения быстрее, чем потребители смогут их обрабатывать? Есть
3 варианта: отбрасывать сообщения, буферизовать их в виде очереди, использовать контроль обратно потока (backpressure).
2) Что произойдет, если узел даст сбой и будет временно недоступен? Будут ли утеряны данные? Как и в случае с БД
могут быть применены различные комбинации записи на диск и/или репликации. 

Типы систем обмена сообщениями:
1) **Прямой обмен сообщениями** - использовать TCP/UDP протоколы для прямой связи инициатора и подписчика. Самый 
быстроработающий способ, но представляющий меньше всего гарантий. Существует большой круг проблем, которые данные системы
не умеют решать и придется решать их на уровне кода. 
2) **Брокеры сообщений** - отправка сообщений осуществляется через отдельный брокер. По существу это своего рода БД, 
оптимизированная для обработки потоков сообщений. Он работает как сервер: инициаторы и подписчики подключаются к нему
как клиенты. Благодаря централизации такие системы умеют из коробки решать многие проблемы: подключение/отключение
клиентов, различные проблемы обеспечения надежности. Результатом очередей является то, что они становятся
асинхронными: инициатор не сможет получить подтверждение обработки от подписчика, только подтверждения получения 
сообщения от брокера. 

Разница между БД и брокером сообщений:
1) Информация в БД хранится до тех пор, пока явно не будет удалена. В то время большинство брокеров сообщений удаляют
сообщение сразу, как оно было доставлено подписчику.
2) Большинство брокеров расчитано на относительно небольшой рабочий набор данных. Если данных становится больше, 
брокерам приходится буферизовать данные на жесткий диск и начинает страдать производительность.
3) Базы поддерживают вторичныек индексы и различные способы поиска данных, в то время брокеры сообщений обеспечивают
только подписку на определенное подмножетство сообщений.

Когда несколько потребителей читают сообщения в одной теме, используются два основных паттерна обмена сообщениями:
1) Распределение нагрузки (рис. 11-1 а) - каждое сообщение доставляется одному подписчику, вследствие чего потребители
могу распределять между собой обработку сообщений в теме. Данный паттерн полезен, когда обработка сообщения занимает
продолжительное время и желательно ее распараллелить.
2) Разветвление (рис. 11-1 б) - каждое сообщения доставляется всем подписчикам. Разветвление позволяет нескольким
потребителям независимо друг от друга читать одну и ту же тему.

![img.png](../../../../img/highload/broker_load_balancing.png)

В любой момент у потребителя может случиться сбой: чтобы не потерять сообщения брокер ждет **подтверждение получения 
сообщения**. Только после подтверждения брокер удалит сообщение. Даже если сообщение на самом деле было обработано, но 
ответ потерялся в сети - брокер еще раз отправит это сообщение. Если использовать распределение нагрузки, то сообщения
могут обработаться **в порядке отличном от порядка отправления**. Более старое сообщение от упавшего потребителя может
перейти к другому потребителю, который уже обработал более новые сообщения.

3) **Брокеры сообщений на базе журналирования** - почему бы не создать гибрид сочетающий надежный подход
хранения данных (БД) и оповещение с малой задержкой (системы обмена сообщений).

Журнал - просто хранящаяся на диске последовательность записей с разрешением только на добавление в конец. Такую 
структуру можно использовать в брокере сообщений. Инициатор добавляет сообщения в конец журнала, а потребитель читает
с конца журнала. Если потребитель дошел до конца журнала, то ждет уведомления о добавлении нового сообщения. Чтобы 
обойти ограничения возможностей одного диска - можно использовать секционирование. Журнал разделяется на разные 
_партиции_ на отдельных машинах (дисках) для распаралеливания записи и обработки. Внутри каждой партиции брокер 
назначает каждому сообщению монотонно увеличивающийся порядковый номер (_смещение, offset_). 

По указанной технологии работают Apache Kafka, Amazon Kinesis Streams, Twitter DistributedLog. Несмотря на то, что 
брокеры записывают все сообщения на диск, они способны обеспечивать пропускную способность до миллионов сообщений в 
секунду за счет секционирования и высокую отказоустойчивость за счет репликаций.

У брокеров на базе журналирования есть еще одна сильная сторона - использование смещение (offset) для потребителей. В
таком случае брокеру (и потребителям) легко понять, какие сообщения уже были прочитаны: те, у которых порядковый номер
меньше смещения (offset). Это позволяет не реализовывать сложную логику слежения за чтением сообщений. Если узел
потребителя вышел из строя, то новый узел может сразу начать читать дальше - достаточно получить offset. Однако
если узел обработал сообщение, но не успел сместить offset - это может привести к проблемам, решение которых мы обсудим
позже.



Что же лучше: традиционные брокеры или брокеры на базе журналирования? Журнал - простейший способ обеспечить рассылку 
сообщений: несколько пользователй могут читать журнал независимо друг от друга, при этом сообщения не удаляются из 
журнала. Партиции помогают равномерное распределение нагрузки. Однако из партиции сообщения читаются последовательно
однопоточным способом. Из-за этого кол-во узлов-потребителей не может быть больше кол-ва партиций и если какое-то
сообщение медленно обрабатывается, то это задерживает обработку остальных сообщений партиции. Таким образом, если
обработка одного сообщения ресурсоемкая, есть желание сильно распаралелить процесс и порядок сообщений не важен, то 
**предпочительнее традиционные брокеры**. В ситуациях с высокой пропускной способностью, быстрой обработкой одного 
сообщения и необходимостью соблюдать последовательность - **лучше использовать брокеры на базе журналирования**.


