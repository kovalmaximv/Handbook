[Назад](./README.md)

1. [Введение](#модели-данных-и-языки-запросов)
2. [Надежность](#реляционная-модель-vs-документоориентированная-модель)  
   2.1 [Объектно реляционное несоответствие](#объектно-реляционное-несоответствие)  
   2.2 [Локальность данных](#локальность-данных)  
   2.3 [Связи many-to-one и many-to-many](#связи-many-to-one-и-many-to-many)  
   2.4 [Какая из моделей приводит к более простому коду](#какая-из-моделей-приводит-к-более-простому-коду)  
   2.5 [Гибкость схемы](#гибкость-схемы)  
   2.6 [Так что же выбрать](#так-что-же-выбрать)

# Модели данных и языки запросов
Под моделями данных здесь подразумеваются различные СУБД (реляционные и не реляционные). 

## Реляционная модель vs Документоориентированная модель
NoSQL базы данных в последнее время на слуху и получают широкое внедрение. Однако стоит помнить, что это не первая 
попытка забрать господство у реляционной модели данных. Как мы видим, все остальные модели смогли занять разве что 
свои ниши использования. Скорее всего, это же ждет и NoSQL базы данных.

Существует несколько причин широкого внедрения NoSQL:
1) Потребность в бОльших возможностях масштабирования, включая обработку бОльших объемов данных.
2) Предпочтение свободного ПО, вместо коммерческих продуктов.
3) Особенные требования к запросам, плохо поддерживаемым реляционными БД.
4) Разочарование ограничениями реляционных схем.

#### Объектно реляционное несоответствие
Одно из разочарований в ограничениях реляционных схем - несоответствие между моделями разработки и хранения данных.

Современная разработка ведется на объектно-ориентированных языках программирования, что идет в разрез с реляционными
моделями данных. Нам необходим промежуточный слой между объектами слоя приложения и данными в БД. Существуют фреймворки
ORM (object-relational mapping) такие, как Hibernate, но они не в состоянии полностью покрыть разницу между двумя 
моделями.

Некоторые данные можно легко и удобно представить в JSON формате. Такие данные обычно называют _документами_. Некоторые
разработчики считают, что модель JSON улучшает согласованность кода со слоем хранения данных. Конечно тут есть свои
недостатки, о них мы поговорим позже. 

#### Локальность данных
У модели JSON лучшая локальность, в отличие от реляционной модели. Там, где в реляционной модели нужно 
несколько запросов с join, в документоориентированной модели хватит запроса одного JSON файла. Однако JSON модель
очень плохо дружит со связями многие-ко-многим.

Локальность данных улучшает производительность запросов, поскольку не нужно прыгать по разным местам на диске. Все 
данные хранятся в одном месте, где их можно прочитать блоком целиком. Но если вам нужен маленький фрагмент этих данных,
то все равно придется грузить целый докумет. Поэтому в большинстве случаев рекомендуется минимизировать размер 
документа.

#### Связи many-to-one и many-to-many
В реляционной модели считается нормальным ссылаться на другие значения в других таблицах. Это позволяет реализовать
связи любого типа. Однако в документоориентированной модели из-за древовидной структуры соединения не нужны, потому что
можно вложить один объект в другой. По этой причине соединения плохо поддерживается в JSON модели. Конечно, эту проблему 
можно решить, если выполнить эту работу на стороне кода, вызывая дополнительные запросы к базе. Однако это 
увеличивает сложность кода и уменьшает производительность системы. 

Чисто теоретически, в документоориентированной модели данных есть такое понятие, как _ссылка на документ_, что 
позволяет реализовать соединения, но популярные БД этого типа (MongoDB, mongoose) не реализовали это понятие, или 
реализовали крайне слабо. По сути указание ID документа и соединение на стороне кода - единственный инструмент,
позволяющий реализовать many-to-many соединения в популярных документоориентированных БД. 

#### Какая из моделей приводит к более простому коду
Если структура данных в приложении документоориентированная (неглубокое дерево связей "one-to-many", где many не 
катастрофически большое множество), то использование документной модели будет более хорошим вариантом. 

Однако если в приложении используются связи many-to-many, документная модель уже не такая привлекательная. Количество 
связей можно сократить, если произвести денормализацию. Однако оставшиеся соединения придется обрабатывать на стороне
кода, вызывая дополнительные запросы. 

#### Гибкость схемы
Документные базы проверяют схему данных при чтении (scheme-on-read). Схема данных неявная и интерпритация этих данных
происходит при чтении. То есть в одной коллекции могут лежать данные разного формата и узнаете вы об этом только при 
чтении данных. Реляционная модель проверяет схему при записи (scheme-on-write) и просто не даст записать данные, если
они не соответствуют схеме таблицы. Споры о том, что правильнее или удобнее можно приравнять к спорам о статической 
и динамической типизации.

Однако стоит помнить про особенности гибкой схемы при работе с миграциями. Если вы изменили или добавили какое-то поле,
то старые данные в коллекции останутся в прежнем формате. Вам будет необходимо на стороне кода делать проверки, какой
версии данные вы только что прочитали. В противовес этому реляционная модель требует миграцию, которая приводит данные 
в таблице к новому виду, но может занять продолжительное время на работу этой миграции.

Гибкая схема будет удобна в следующих случаях: данные неоднородны или структура данных определяется внешней системой. В
подобных случаях схема может принести больше вреда, чем пользы. 

#### Так что же выбрать
Основные доводы в пользу документной модели данных:
1) Гибкость схемы (Scheme on read)
2) Лучшая производительность в следствии локальности данных
3) Большая близость к применяемым структурам данных в коде

Доводы в пользу реляционной модели:
1) Лучшая поддержка соединений
2) Отсутствие гибкости схемы (Scheme on write)

Стоит отметить, что интересна тенденция, как документные и реляционные модели движутся на встречу друг другу. Многие
популярные реляционные модели поддерживают JSON тип данных, а документные модели активно пытаются реализоваться
соединения на основе документных ссылок. Возможно, в будущем мы увидим гибрид этих двух моделей данных.