[Назад](./README.md)

1. [Введение](#модели-данных-и-языки-запросов)
2. [Надежность](#реляционная-модель-vs-документоориентированная-модель)  
   2.1 [Объектно реляционное несоответствие](#объектно-реляционное-несоответствие)  
   2.2 [Локальность данных](#локальность-данных)  
   2.3 [Связи many-to-one и many-to-many](#связи-many-to-one-и-many-to-many)  
   2.4 [Какая из моделей приводит к более простому коду](#какая-из-моделей-приводит-к-более-простому-коду)  
   2.5 [Гибкость схемы](#гибкость-схемы)  
   2.6 [Так что же выбрать](#так-что-же-выбрать)

# Модели данных и языки запросов
Под моделями данных здесь подразумеваются различные СУБД (реляционные и не реляционные). 

## Реляционная модель vs Документоориентированная модель
NoSQL базы данных в последнее время на слуху и получают широкое внедрение. Однако стоит помнить, что это не первая 
попытка забрать господство у реляционной модели данных. Как мы видим, все остальные модели смогли занять разве что 
свои ниши использования. Скорее всего, это же ждет и NoSQL базы данных.

Существует несколько причин широкого внедрения NoSQL:
1) Потребность в бОльших возможностях масштабирования, включая обработку бОльших объемов данных.
2) Предпочтение свободного ПО, вместо коммерческих продуктов.
3) Особенные требования к запросам, плохо поддерживаемым реляционными БД.
4) Разочарование ограничениями реляционных схем.

#### Объектно реляционное несоответствие
Одно из разочарований в ограничениях реляционных схем - несоответствие между моделями разработки и хранения данных.

Современная разработка ведется на объектно-ориентированных языках программирования, что идет в разрез с реляционными
моделями данных. Нам необходим промежуточный слой между объектами слоя приложения и данными в БД. Существуют фреймворки
ORM (object-relational mapping) такие, как Hibernate, но они не в состоянии полностью покрыть разницу между двумя 
моделями.

Некоторые данные можно легко и удобно представить в JSON формате. Такие данные обычно называют _документами_. Некоторые
разработчики считают, что модель JSON улучшает согласованность кода со слоем хранения данных. Конечно тут есть свои
недостатки, о них мы поговорим позже. 

#### Локальность данных
У модели JSON лучшая локальность, в отличие от реляционной модели. Там, где в реляционной модели нужно 
несколько запросов с join, в документоориентированной модели хватит запроса одного JSON файла. Однако JSON модель
очень плохо дружит со связями многие-ко-многим.

Локальность данных улучшает производительность запросов, поскольку не нужно прыгать по разным местам на диске. Все 
данные хранятся в одном месте, где их можно прочитать блоком целиком. Но если вам нужен маленький фрагмент этих данных,
то все равно придется грузить целый докумет. Поэтому в большинстве случаев рекомендуется минимизировать размер 
документа.

#### Связи many-to-one и many-to-many
В реляционной модели считается нормальным ссылаться на другие значения в других таблицах. Это позволяет реализовать
связи любого типа. Однако в документоориентированной модели из-за древовидной структуры соединения не нужны, потому что
можно вложить один объект в другой. По этой причине соединения плохо поддерживается в JSON модели. Конечно, эту проблему 
можно решить, если выполнить эту работу на стороне кода, вызывая дополнительные запросы к базе. Однако это 
увеличивает сложность кода и уменьшает производительность системы. 

Чисто теоретически, в документоориентированной модели данных есть такое понятие, как _ссылка на документ_, что 
позволяет реализовать соединения, но популярные БД этого типа (MongoDB, mongoose) не реализовали это понятие, или 
реализовали крайне слабо. По сути указание ID документа и соединение на стороне кода - единственный инструмент,
позволяющий реализовать many-to-many соединения в популярных документоориентированных БД. 

#### Какая из моделей приводит к более простому коду
Если структура данных в приложении документоориентированная (неглубокое дерево связей "one-to-many", где many не 
катастрофически большое множество), то использование документной модели будет более хорошим вариантом. 

Однако если в приложении используются связи many-to-many, документная модель уже не такая привлекательная. Количество 
связей можно сократить, если произвести денормализацию. Однако оставшиеся соединения придется обрабатывать на стороне
кода, вызывая дополнительные запросы. 

#### Гибкость схемы
Документные базы проверяют схему данных при чтении (scheme-on-read). Схема данных неявная и интерпритация этих данных
происходит при чтении. То есть в одной коллекции могут лежать данные разного формата и узнаете вы об этом только при 
чтении данных. Реляционная модель проверяет схему при записи (scheme-on-write) и просто не даст записать данные, если
они не соответствуют схеме таблицы. Споры о том, что правильнее или удобнее можно приравнять к спорам о статической 
и динамической типизации.

Однако стоит помнить про особенности гибкой схемы при работе с миграциями. Если вы изменили или добавили какое-то поле,
то старые данные в коллекции останутся в прежнем формате. Вам будет необходимо на стороне кода делать проверки, какой
версии данные вы только что прочитали. В противовес этому реляционная модель требует миграцию, которая приводит данные 
в таблице к новому виду, но может занять продолжительное время на работу этой миграции.

Гибкая схема будет удобна в следующих случаях: данные неоднородны или структура данных определяется внешней системой. В
подобных случаях схема может принести больше вреда, чем пользы. 

#### Так что же выбрать
Основные доводы в пользу документной модели данных:
1) Гибкость схемы (Scheme on read)
2) Лучшая производительность в следствии локальности данных
3) Большая близость к применяемым структурам данных в коде

Доводы в пользу реляционной модели:
1) Лучшая поддержка соединений
2) Отсутствие гибкости схемы (Scheme on write)

Стоит отметить, что интересна тенденция, как документные и реляционные модели движутся на встречу друг другу. Многие
популярные реляционные модели поддерживают JSON тип данных, а документные модели активно пытаются реализоваться
соединения на основе документных ссылок. Возможно, в будущем мы увидим гибрид этих двух моделей данных.

## Языки запросов для данных
Для начала стоит вспомнить определения императивных и декларативных языков. Декларативные языки (например SQL) 
говорят что нужно сделать, но не говорят как это сделать. Причина такого подхода в использовании специального
оптимизатора, который сам решит, как быстрее сделать то, что попросил программист. Императивные языки говорят 
компьютеру какие шаги необходимо выполнить. 

#### MapReduce
MapReduce - модель программирования для обработки большого количества данных на нескольких машинах, активно 
продвигаемая Google. Эта модель не является ни императивным, ни декларативным языком программирования. Это нечто 
среднее: логика запроса выражается с помощью двух функциональных комманд `map` для уточнения поиска и `reduce` для
приведения ответа к определенному виду.

_Пример_: у нас есть таблица, в которую записываются морские обитатели, вошедшие в наш залив. Допустим, что мы хотим
получить всех акул, побывавших в заливе за месяц. На SQL такой запрос будет выглядеть примерно так:

```sql
SELECT date_trunc('month', observation_timestamp) AS observation_month,
       sum(num_animals) AS totals_animals
FROM observations
WHERE family = 'sharks'
GROUP BY observation_month;
```

А при помощи MapReduce модели базы данных MongoDB это выглядело бы так:

```java 
db.observation.mapReduce(
   function map() { // вызывается для каждого документа, прошедшего проверку query
      var year = this.observationTimestamp.getFullyYear();
      var month = this.observationTimestamp.getMonth() + 1;
      emit(year + "-" + month, this.numAnimals);
   },
   
   function reduce(key, values) { // группирует порождаемые map значения 
      return Array.sum(values);
   },
   
   {
      query: {family: "sharks"; }, // отсеиваем только акул
      out: "monthlySharkReport" // результат записываем в коллекцию monthlySharkReport
   }
)
```

Функций `map` и `reduce` обязательно должны быть чистыми. То есть могут использовать только передаваемые в них 
входные данные и не должны иметь побочных эффектов работы. Такие ограничения позволяют БД выполнять эти функции где 
угодно, в любом порядке и перезапускать их в случае какой-то неудачи. 

#### Графоподобные модели данных
Графоподобная модель данных самая естественная для случая, когда в данных часто встречаются связи many-to-many. Графы
состоят из вершин (vertice), известных так же как узлы или сущности, и ребер (edge), известных так же как связи или 
дуги. В графах можно хранить однородные данные, например граф социальных связей, каждая вершина которого это человек.
В графах так же возможно хранить неоднородные данные. Например Facebook поддерживает единый граф с множестом различных 
типов вершин и ребер (пользователи, комментарии, местоположения, события, etc).

Существует несколько способов структурирования графовых моделей, мы рассмотрим граф свойств (СУБД Neo4j, Titan и 
InfiniteGraph) и модель хранилища тройных кортежей (СУБД Datomic, AllegroGraph).

#### Граф свойств и язык запросов CYPHER
В модели графов свойств каждая вершина состоит из:
* уникального идентификатора
* множества исходящих и входящих ребер
* коллекции свойств (ключ-значение)

Каждое ребро состоит из:
* уникального идентификатора
* вершины с которой ребро начинается и заканчивается
* коллекции свойств (ключ-значение)

Важные аспекты такого графа:
1) Любая вершина может быть соединена с любой другой вершиной (схема не накладывает ограничений)
2) Для любой вершины можно найти все входящие и исходящие ребра и таким образом выполнить обход графа
3) Метки на ребрах позволяют обозначить вид связи и хранить в графе разные виды информации

Cypher - декларативный язык запросов для графов свойств, созданный для СУБД Neo4j. Вот так выглдядит пример вставки
данных в граф:
```
CREATE
   (NAmerica:Location {name: 'North America', type: 'continent'}),
   (USA:Location      {name: 'United States', type: 'country'}),
   (Idaho:Location    {name: 'Idaho',         type: 'state'}),
   (Lucy:Person       {name: 'Lucy'),
   (Idaho) -[:WITHIN]-> (USA) -[:WITHIN]-> (NAmerica),
   (Lucy)  -[:BORN_IN]-> (Idaho)
```

Каждой вершине дано название (например USA или Idaho). Остальные части запроса могут использовать эти названия чтобы
создать ребра между вершинами. Теперь попробуем найти всех людей, эмигрировавших из США в Европу. Точнее нужно найти
все вершины, у которых ребро BORN_IN указывает на город из США, а ребро LIVING_IN на город из Европы. 
Пример такого запроса:
```
MATCH
   (person) -[:BORN_IN]-> () -[:WITHIN*0..]-> (us: Location {name: 'United States'}),
   (person) -[:LIVES_IN]-> () -[WITHIN*0..]-> (eu: Location {name: 'Europe'})
RETURN person.name
```

Этот запрос расшифровывается так:
1) Найти все вершины (назовем их person) удовлетворяющие _обоим_ условиям:
   - У вершины person есть исходящее ребро `BORN_IN` уходящее к неважно какой вершине. Важно, что от этой вершины можно
   построить цепочку исходящих ребер `WITHIN` вплоть до вершины типа `Location` с именем United States.
   - У вершины person есть исходящее ребро `LIVES_IN` уходящее к неважно какой вершине. Важно, что от этой вершины можно
   построить цепочку исходящих ребер `WITHIN` вплоть до вершины типа `Location` с именем Europe.
2) Вернуть свойство name для всех подошедших вершин.

#### Хранилище тройных кортежей и SPARQL