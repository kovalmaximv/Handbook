[Назад](./README.md)

1. [Введение](#сериализация)
2. [Форматы кодирования данных](#форматы-кодирования-данных)  
   2.1. [Форматы ориентированные на конкретные языки](#форматы-ориентированные-на-конкретные-языки)

# Сериализация
Приложения неизбежно обмениваются данными с течением времени. Для отправки данных необходимо выбрать общий формат, 
в который сможет закодировать отправитель и прочитать получатель. Процесс кодирования данных называется _сериализацией_, 
а процесс декодирования - _десериализацией_. Данные неизбежно будут меняться, добавляться новые поля или изменяться 
формат/тип существующих. Поэтому очень важно продумать процесс эволюции кодируемых данных (прямая и обратная 
совместимость данных).  

О сериализация и поддержке эволюции данных пойдет речь в данной главе.

## Форматы кодирования данных
Сериализация или кодирование - процесс преобразования из объектов и структур в памяти в последовательности 
байтов, пригодную для отправки по сети. Обратная операция называется десериализация или декодирование. 

#### Форматы ориентированные на конкретные языки
Во многих языках есть встроенные механизмы сериализации, например как `java.io.Serialization` в Java. Эти механизмы 
удобны тем, что позволяют сериализовать необходимые данные с помощью минимального количества кода. Однако у этого 
механизма есть свои проблемы:
1) Встроенный механизм сериализации может быть привязан к конкретному языку. 
2) Процесс декодирования имеет возможность создавать произвольные классы, что является дырой в безопасности.
3) Контроль версий в этих механизмах зачастую неудобны.
4) Эффективность порой тоже оставляет желать лучшего.

Вследствие этого, использование встроенных механизмов сериализации в долгосрочной перспективе обычно является плохой 
идеей.

#### JSON, XML и двоичные типы данных
JSON, XML и CSV - текстовые универсальные форматы, относительно удобочитаемые для людей. Однако у них есть ряд проблем:
1) **Кодирование чисел** приводит к неоднозначностям. В XML и CSV невозможно различить число и строку, состоящую из цифр.
JSON различает числа и строки, но не различает целые значения и значения с плавающей точкой. Так же существует проблема
относительно больших чисел: если в одном ЯП число валидно, то для другого оно может стать слишком большим. 
2) В XML и JSON есть дополнительная поддержка схемы данных (прямо как в БД), но сложны в использовании.
3) В CSV нет никакой схемы, поэтому тип данных каждого столбца определяет само приложение. 

Но несмотря на эти изъяны, JSON/XML/CSV достаточно хороши для многих целей: они легки в понимание, читаемы для людей и 
выполняют свои формата сериализованных данных. Однако данный формат отнюдь не компактный. Для случаев, когда это важно,
существуют **двоичные форматы** сериализации. Например двоичные форматы JSON (BSON, BJSON, BISON, etc) и XML 
(WBXML, Fast Infoset, etc). Эти форматы применяются в некрупных сегментах рынка и ни один из них не задействован так
широко, как JSON/XML/CSV. 

#### Thrift и Protocol Buffers
Apache Thrift и Protocol Buffers (protobuf) - библиотеки двоичного кодирования для передачи данных. Оба фреймворка
требуют наличия схемы данных для работы. Оба фреймворка содержат утилиту генерации кода, которые на основе схемы 
могут генерировать классы (не только DTO, но и API).

Пример схемы данных Thrift:
```
struct Person {
    1: required string       username,
    2: optional i64          favoriteNumber,
    3: optional list<string> interests
}
```

Закодированная запись представляет собой конкатенацию полей, каждое поле определенно своим номером тега и помечено 
типом данных. Если значение поля не задано, оно просто не включается в закодированную запись. Можно поменять название
полей в схеме, но **нельзя поменять тег поля**, так как из-за этого все уже закодированные данные превратятся в 
неправильные. В схему можно **добавлять новые поля**, но новому полю нужно задать новый порядковый номер тега и нельзя
его делать обязательным, это поломает совместимость. Старый код, для которого еще неизвестно это поле с новым тегом, 
будет его просто игнорировать. Так же можно **удалять поля** их схемы, но можно удалять только необязательные поля 
и нельзя использовать один и тот же номер тега повторно. 

У этих библиотек есть ряд достоинств:
1) Закодированные данные компактнее, чем у двоичного JSON
2) Схема - важный вид документации API
3) Генерация кода

Из минусов можно выделить:
1) Необходимость погружения в технологию для новых разработчиков
2) Меньшая популярность, чем JSON/XML
3) Нечитаемые (для человека) данные, передающиеся по сети