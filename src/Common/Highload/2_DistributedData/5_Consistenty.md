# Согласованность и консенсус
Согласованность в системе БД - обязательная для решения задача в системах распределенного хранения данных. Существует 
несколько способов реализации согласованности, ниже мы рассмотрим несколько из них. 

Однако согласованность не решает всех проблем с распределенным хранением и обработкой данных. Зачастую для нескольких
узлов необходимо составить единое решение о какой-то проблемы конкурентной работы. Решением этой проблемы является 
консенсунс. Обеспечение консенсуса - удивительно сложная задача.

## Гарантии согласованности
Большинство реплицированных БД гарантируют конечную согласованность (eventually consistency), однако это очень слабая 
гарантия. Она ничего не говорит о том, когда данные будут консистентны и до этого момента операции чтения возвращать
что угодно или вообще ничего. При работе с такой БД надо постоянно помнить об этих ограничениях. Такое поведение очень
сильно отличается от классического однопоточного выполнения программ, когда свежезаписанную переменную можно прочитать
и получить новое значение. Отсюда часто возникают ошибки, которые довольно сложно отловить на этапе тестирования.

Существуют более сильные модели согласованности. У каждой из них есть своя цена: системы с более сильной согласованностью
имеют худшую производительность или быть менее отказоустойчивыми.

## Линеаризуемость
Линеаризуемость - свойство, которое гарантирует, что любая операция чтения или записи в базу данных будет выполнена
атомарно и в определенном порядке. Например, если два пользователя пытаются изменить одну и ту же запись в базе данных,
то линеаризуемость гарантирует, что только одно из этих изменений будет выполнено первым, а второе будет выполнено после
того, как первое изменение будет завершено. Это предотвращает возможные конфликты и ошибки в данных. Под капотом
линеаризуемость работает при помощи блокировок и транзакций.

> :exclamation: **Линеаризуемость - самая сильная гарантия согласованности.**

В линеаризуемой системе предполагается, что есть некий момент времени (во время записи), при котором значение меняется 
со старого на новое. После этого момента времени _все_ последующие операции чтения обязаны возвращать новое значение.

Список областей, в которых может понадобиться линеаризуемость:
1) **Блокировка и выбор ведущего узла**: у всех узлов в системе должно быть единое понимание, кто является 
ведущим узлом. На деле чаще всего это решается при помощи инструментов по типу Zookeeper, который используется 
для решения консенсусный алгоритм.
2) **Ограничения и гарантия уникальности**: чтобы поддерживать уникальность некоторого поля, нужна линеаризуемость, ведь
в случае конкурентной записи необходимо однозначно определить, кто запишет значение первым, а кому не дать записать
повторяющееся значение.
3) **Межканальные синхронизационные зависимости**: в случае если один сервис записывает данные в БД, а другой из нее 
читает (тут же или через некоторое время), эта БД должна быть линеаризуема, чтоб второй сервис смог получить
свежезаписанные данные.

Реализация линеаризуемых систем:
1) **Репликация с одним ведущим узлом**: потенциально линеаризуемо. Если чтение происходит из мастер или 
синхронизированных реплик, то такая система линеаризуема. Однако на практике этому может помешать архитектура БД или 
ошибки возникающие из-за конкурентных операций. Архитектурно мешают следующие нюансы: чтение из всех реплик, 
неправильный выбор нового мастера, изоляция снимков состояния, етс.
2) **Консенсусные алгоритмы**: БД построенные на основе консенсусных алгоритмов (Zookeeper) тоже могут быть 
линеаризированы. Все благодаря алгоритмам, которые лежат в их основе, их мы рассмотрим дальше.
3) **Репликация с несколькими ведущими узлами**: не являются линеаризуемыми из-за их конкурентной природы записи.
4) **Репликация без ведущего узла**: иногда можно получить подобие линеаризуемости, если правильно настроить 
кворум (w + r > n).

Важно знать про **цену линеаризуемости**, коротко ее можно выделить так:
1) Если приложение _требует_ линеаризуемость, то в случае проблем в сети часть реплик могут стать недоступными (потому что
не могут связаться с другими репликами для синхронизации). Таким образом, мы _теряем доступность_.
2) Если приложение _не требует_ линеаризуемость, то в случае проблем в сети реплики продолжат работу (потому что
им больше не нужно синхронизироваться). Таким образом мы _получаем высокую доступность_, хоть и теряем линеаризуемость.

Если совсем коротко, то приложения не требующие линеаризуемости, более устойчивы к неполадкам в сети. Это представление
более широко известно как **CAP теорема**.

Аббревиатура CAP расшифровывается как Consistency, Availability, Partition Tolerance (Согласованность, Доступность,
Устойчивость к нарушению связности). При нарушении связности можно выбрать только что-то одно: согласованность данных
или доступность БД в целом. Таким образом, любая система БД может быть AP или CP.

Зачастую в современных системах отказываются от линеаризуемости, только не в угоду доступности, а в угоду 
_быстродействию_. Именно поэтому сейчас активно приходят новые теоремы на смену CAP. В реальных сетях с задержками
линеаризуемость работает **медленно**. Быстрых алгоритмов для линеаризуемости еще не придумали, однако можно более слабые
модели согласованности данных и таким образом ускорить систему. 

## Гарантии упорядоченности
Более слабая версия согласованности - упорядоченность (причинность, ordering). Даная гарантия упорядочивает зависимые
операции, но допускает параллельную обработку независимых операций. Можно провести параллель с git, где коммиты в одной
ветки строго упорядоченны, но коммиты из разных веток могут быть параллельны. Можно сказать, что линеаризуемость - 
абсолютная упорядоченность, поскольку любые два действия будут упорядочены относительно друг друга, мы уже рассматривали,
к каким накладным расходам это может привести. Зачастую системам хватает упорядоченности для правильной и быстрой работы.

Для сохранения причинно-следственных связей используются _порядковые номера_ или _временные метки_. Такая метка 
ставится не по физическим часам, а по логическим часам - алгоритм генерации последовательности чисел для 
идентификаций операций. Такая метка является компактной и может обеспечивать полную упорядоченность, поскольку любые
две операции имеют свой номер и по нему можно понять порядок операций. Конкурентные операции могут быть упорядочены
произвольно.

В базе данных с одним ведущим узлом именно он монотонно генерирует эту последовательность номеров. Таким образом, если
реплика выполняет операции в порядке согласно номерам, то его состояние всегда является причинно-упорядоченным. 