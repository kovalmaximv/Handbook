# Транзакции
Транзакции представляют собой цепочку операций, которая либо выполняется успешно (с фиксацией изменений), либо 
неудачно (с прерыванием цепочки и откатом изменений). По сути транзакции - способ борьбы со сбоями информационных 
систем, обработку таких ошибок и сбоев перед на себя база данных.

## Смысл аббревиатуры ACID
Гарантии, которые предоставляют транзакции, обычно описывают известной аббревиатурой ACID:
- Atomicity (атомарность)
- Consistency (согласованность)
- Isolation (изоляция)
- Durability (долговечность)

На практике реализация ACID отличается от базе к базе, особенно серьезные различия в понимании термина _изоляция_. 
На сегодняшний день заявление о совместимости какой-то БД с ACID не дает четкого определения о предоставляемых 
гарантиях.

#### Атомарность
Атомарность говорит нам о том, что если транзакцию не удалось завершить, то она прерывает дальнейшее выполнение и 
откатывает уже выполненные изменения. Благодаря атомарности можно быть уверенным, что в случае сбоя можно просто
еще раз повторить транзакцию и никакие данные не задублируются.

#### Согласованность
Транзакция должна приводить БД из одного допустимого состояния (инварианта) в другой допустимый. Иначе говоря, 
данные до и после транзакции должны быть согласованны, за это и отвечает данное свойство. 

Однако это довольно спорная гарантия транзакций, поскольку согласованность данных зачастую обеспечивается самим 
приложением и БД просто не может гарантировать согласованность бизнес требований. Можно даже сказать, что 
согласованность на самом деле является свойством приложения, а не транзакции.

#### Изоляция
Изоляция гарантирует, что конкурентно выполняемые транзакции изолированы друг от друга и не могут помешать друг другу.
Сериализуемость (транзакции выполняются как будто последовательно) - крайняя степень изоляции, однако она несет с 
собой большие издержки, так что зачастую используют другие механизмы изоляции.

#### Долговечность
Долговечность - обязательство базы не терять результат успешно зафиксированных транзакций даже в случае аппаратного 
сбоя.

## Уровни изоляции
Проблемы конкурентного доступа возникают, когда одна транзакция читает/изменяет данные, модифицируемые в этот момент
другой транзакцией.

Существует множество уровней изоляций транзакций. Сериализуемость - самый безопасный из них, но при этом очень дорогой.
Многие БД используют другие механизмы изоляции, которые защищают от _части_ проблем конкурентного доступа. Многие 
популярные БД используют слабую изоляцию, так что обязательно нужно читать документацию, чтобы понять потенциальные 
ошибки.

#### Read committed
Read committed (чтение зафиксированных данных) - самый базовый уровень изоляции. Он обеспечивает 2 гарантии:
- При чтении из БД клиент видит только зафиксированные (закомиченные) данные других транзакций
- При записи данных клиент может перезаписать только зафиксированные данные других транзкций

Ситуация, когда транзакция прочитала незафиксированные данные другой транзакции называется _грязное чтение_ 
(**dirty read**). Read committed защищает от такой проблемы:

![img.png](../../../../img/highload/dirty_read_fix.png)

Примеры проблем возникающие при грязном чтении:
1) Когда транзакция должна обновить несколько значений, а успела обновить только часть и другая транзакция 
прочитала только часть обновленных данных. Получим несогласованные данные при чтении
2) Транзакция может прочитать данные, которые другая транзакция позже откатит

Read Comitted - очень популярный уровень изоляции. Он используется по умолчанию в Oracle, PostgreSQL и SQLServer. 
Чаще всего уровень реализуют с помощью блокировки строк: прежде чем изменить конкретный объект, транзакция устанавливает
блокировку на этот объект. Данная блокировка удерживается до коммита или отката транзакции. Удерживать блокировку может
только одна транзакция одновременно. Подобные блокировки БД выполняют автоматически на уровне изоляции read comitted 
или на более сильных уровнях изоляции.

Первый способ предотвращения грязного чтения - запретить читать заблокированные данные. Однако на деле это приводит к 
большим издержкам. Поэтому большинство БД используют другой способ: база запоминает для каждого измененного объекта 
как старое значение, так и новое, устанавливаемое транзакцией. Во время выполнения транзакции всем другим транзакциям
возвращается старое значение. Только после коммита транзакцией новое значение могут считать другие транзакции.


#### Repeatable Read