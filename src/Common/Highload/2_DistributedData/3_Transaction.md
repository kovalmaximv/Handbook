[Назад](./README.md)

1. [Смысл аббревиатуры ACID](#смысл-аббревиатуры-acid)  
   1.1. [Атомарность](#атомарность)  
   1.2. [Согласованность](#согласованность)  
   1.3. [Изоляция](#изоляция)  
   1.3. [Долговечность](#долговечность)  
2. [Проблемы изолированности транзакций](#проблемы-изолированности-транзакций)  
   2.1. [Dirty read](#dirty-read)  
   2.2. [Non-repeatable read](#non-repeatable-read)  
   2.3. [Lost update](#lost-update)  
   2.3. [Асимметрия записи и фантомы](#асимметрия-записи-и-фантомы)  
3. [Уровни изоляции](#уровни-изоляции)  
   3.1. [Read committed](#read-committed)   
   3.2. [Repeatable Read](#repeatable-read)   
   3.2. [Serializable](#serializable)   
4. [Резюме](#резюме)

# Транзакции
Транзакции представляют собой цепочку операций, которая либо выполняется успешно (с фиксацией изменений), либо 
неудачно (с прерыванием цепочки и откатом изменений). По сути транзакции - способ борьбы со сбоями информационных 
систем, обработку таких ошибок и сбоев перед на себя база данных.

## Смысл аббревиатуры ACID
Гарантии, которые предоставляют транзакции, обычно описывают известной аббревиатурой ACID:
- Atomicity (атомарность)
- Consistency (согласованность)
- Isolation (изоляция)
- Durability (долговечность)

На практике реализация ACID отличается от базе к базе, особенно серьезные различия в понимании термина _изоляция_. 
На сегодняшний день заявление о совместимости какой-то БД с ACID не дает четкого определения о предоставляемых 
гарантиях.

#### Атомарность
Атомарность говорит нам о том, что если транзакцию не удалось завершить, то она прерывает дальнейшее выполнение и 
откатывает уже выполненные изменения. Благодаря атомарности можно быть уверенным, что в случае сбоя можно просто
еще раз повторить транзакцию и никакие данные не задублируются.

#### Согласованность
Транзакция должна приводить БД из одного допустимого состояния (инварианта) в другой допустимый. Иначе говоря, 
данные до и после транзакции должны быть согласованны, за это и отвечает данное свойство. 

Однако это довольно спорная гарантия транзакций, поскольку согласованность данных зачастую обеспечивается самим 
приложением и БД просто не может гарантировать согласованность бизнес требований. Можно даже сказать, что 
согласованность на самом деле является свойством приложения, а не транзакции.

#### Изоляция
Изоляция гарантирует, что конкурентно выполняемые транзакции изолированы друг от друга и не могут помешать друг другу.
Сериализуемость (транзакции выполняются как будто последовательно) - крайняя степень изоляции, однако она несет с 
собой большие издержки, так что зачастую используют другие механизмы изоляции.

#### Долговечность
Долговечность - обязательство базы не терять результат успешно зафиксированных транзакций даже в случае аппаратного 
сбоя.

## Проблемы изолированности транзакций
#### Dirty read
Ситуация, когда транзакция прочитала незафиксированные данные другой транзакции называется _грязное чтение_
(**dirty read**). Read committed защищает от такой проблемы:

![img.png](../../../../img/highload/dirty_read_fix.png)

Примеры проблем возникающие при грязном чтении:
1) Когда транзакция должна обновить несколько значений, а успела обновить только часть и другая транзакция
   прочитала только часть обновленных данных. Получим несогласованные данные при чтении
2) Транзакция может прочитать данные, которые другая транзакция позже откатит

Первый способ предотвращения грязного чтения - запретить читать заблокированные данные. Однако на деле это приводит к
большим издержкам. Поэтому большинство БД используют другой способ: база запоминает для каждого измененного объекта
как старое значение, так и новое, устанавливаемое транзакцией. Во время выполнения транзакции всем другим транзакциям
возвращается старое значение. Только после коммита транзакцией новое значение могут считать другие транзакции.

Для решения использовать уровень изоляции read commited.

#### Non-repeatable read
Ситуация, когда изменения одной транзакции мешают чтению данных другой транзакции, при которой она читает
несогласованные данные - называется **non-repeatable read**. То есть пострадавшая транзакция может дважды прочитать
одни и те же данные и дважды получить разный результат.

![img.png](../../../../img/highload/nonrepeatable_read.png)

Для решения этой проблемы чаще всего используют _изоляцию снимков состояния_ (**snapshot isolation**). Ее идея состоит
в том, что каждая транзакция читает данные из согласованного снимка состояния БД. То есть видит данные, которые были
зафиксированы на момент начала этой транзакции. Даже если данные затем изменены другой транзакцией, каждая транзакция
видит только старые данные.

Для решения использовать уровень изоляции repeatable read.

#### Lost update
При конкурентном выполнении транзакций возможна проблема _потери обновлений_ (**lost update**). Проблем может возникать,
когда транзакция читает данные, изменяет их и записывает обратно. При конкурентном выполнении такого действия мы можем
потерять одно из изменений.

Способы решения:
1) Атомарные операции записи

Доступны, когда описываемое изменение можно описать в SQL запросе, например
```sql
UPDATE customers SET value = value + 1 WHERE key = 'foo'
```

2) Явные блокировки

Блокировка при помощи `SELECT ... FOR UPDATE` после которого приложение может изменять данные. Другим транзакциям при
попытке изменения этих данных придется ждать.

3) Автоматическое обнаружение потери обновлений

Можно разрешить транзакциям выполняться конкурентно, но проверять: изменилось ли значение после чтение и до изменения
данных. Если изменилось, попробовать снова. Этакий аналог `compare-and-swap`

#### Асимметрия записи и фантомы
Асимметрия записи - когда две конкурентные транзакции изменяют данные и нарушают бизнес требования/ограничения. Например,
необходимо, чтобы кабинетом пользовались не более 1 человека, но в какой-то момент две транзакции двух разных
пользователей одномоментно смогли занять кабинет. Ассиметрию можно рассматривать как обобщение проблемы потери
обновлений.

Фантом - операция записи в одной транзакции меняет результат запроса на поиск в другой.

Способы решения: использовать уровень сериализуемости или явная блокировка строк необходимых для обновления с помощью
`SELECT FOR UPDATE`.

## Уровни изоляции
Проблемы конкурентного доступа возникают, когда одна транзакция читает/изменяет данные, модифицируемые в этот момент
другой транзакцией.

Существует множество уровней изоляций транзакций. Сериализуемость - самый безопасный из них, но при этом очень дорогой.
Многие БД используют другие механизмы изоляции, которые защищают от _части_ проблем конкурентного доступа. Многие 
популярные БД используют слабую изоляцию, так что обязательно нужно читать документацию, чтобы понять потенциальные 
ошибки.

#### Read committed
Read committed (чтение зафиксированных данных) - самый базовый уровень изоляции. Он обеспечивает 2 гарантии:
- При чтении из БД клиент видит только зафиксированные (закомиченные) данные других транзакций (грязное чтение)
- При записи данных клиент может перезаписать только зафиксированные данные других транзкций

Read Comitted - очень популярный уровень изоляции. Он используется по умолчанию в Oracle, PostgreSQL и SQLServer. 
Чаще всего уровень реализуют с помощью блокировки строк: прежде чем изменить конкретный объект, транзакция устанавливает
блокировку на этот объект. Данная блокировка удерживается до коммита или отката транзакции. Удерживать блокировку может
только одна транзакция одновременно. Подобные блокировки БД выполняют автоматически на уровне изоляции read comitted 
или на более сильных уровнях изоляции.

#### Repeatable Read
Данный уровень изоляции имеет различные названия в разных БД. В Oracle он называется уровнем сериализации 
(serializable), а в PostgreSQL и MySQL - воспроизводимым чтением (repeatable read).

Ситуация, когда изменения одной транзакции мешают чтению данных другой транзакции, при которой она читает 
несогласованные данные - называется **non-repeatable read**. То есть пострадавшая транзакция может дважды прочитать 
одни и те же данные и дважды получить разный результат.

![img.png](../../../../img/highload/nonrepeatable_read.png)

Для решения этой проблемы чаще всего используют _изоляцию снимков состояния_ (**snapshot isolation**). Ее идея состоит
в том, что каждая транзакция читает данные из согласованного снимка состояния БД. То есть видит данные, которые были
зафиксированы на момент начала этой транзакции. Даже если данные затем изменены другой транзакцией, каждая транзакция
видит только старые данные.

Реализуют это с помощью списка версий объектов, по версии для каждой транзакции. Такой механизм получил название
многоверсионное управление конкурентным доступом (multiversion concurrency control, MVCC). В самом начале выполнения 
транзакция получает уникальный, монотонно возрастающий идентификатор (txid). При каждой записи транзакцией новые 
данные помечаются номером этой транзакции (поле created_by). Если транзакция удаляет строку, она записывается в поле
deleted_by. Изменение строки == удаление старой строки и создание новой. В дальнейшем, когда уже никакая транзакция 
не обратится к удаленным данным, сборщик мусора БД очистит эти данные. 

![img.png](../../../../img/highload/mvcc_example.png)

Выполняя чтение транзакция использует идентификатор, чтобы понять, какие данные она может прочитать. Правило видимости
таковы:
1) В начале каждой транзакции БД определяет список выполняемых, но еще не зафиксированных транзакций. Все выполняемые
этими транзакциями изменения игнорируются, даже если впоследствии будут зафиксированы.
2) Все операции записи выполненные транзакцией с более поздним txid игнорируются независимо от их результата.
3) Результаты всех остальных транзакций видны.

Другими словами версия объекта видна, если:
1) На момент начала читающей транзакции создавшая объект транзакция уже зафиксирована
2) Объект не помечен на удаление. Если помечен, то запросившая удаление транзакция не была зафиксирована на момент 
начала читающей транзакции

##### Serializable
Сериализуемость (Serializable) - самый сильный уровень изоляции транзакций. Даже при конкурентном выполнении нескольких 
транзакций результат будет такой же, как если бы они выполнялись последовательно. База предотвращает все возможные 
состояния гонки.

Современные БД используют один из следующих способов достижения сериализуемости:
1) Действительно последовательное выполнение транзакций
2) Двухфазная блокировка (2PL)
3) Сериализуемая изоляция снимков состояния (SSI)

#### Последовательное выполнение транзакций
Простейший способ избежать проблем с конкурентным доступом - отказаться от него: выполнять транзакции последовательно.

Из-за большой цены сетевого взаимодействия в системах одногопоточного выполнения транзакций запрещены многооператорные
транзакции. Вместо них код бизнес кода транзакций помещается в хранимые процедуры и вместо нескольких запросов в БД
выполняется одна большая хранимая процедура. Хранимая процедура выполняется очень быстро, если все необходимые ей данные
подгруженны в оперативную память.

Последовательное выполнение сильно нагружает единственное ядро процессора. Для системы с высокой нагрузкой по записи
это может быть узким местом. Для масштабирования на несколько ядер можно партиционировать БД. Но если каждая транзакция
будет занимать несколько партиций, то вся система может встать во взаимных блокировках партиций.

Краткое резюме последовательного выполнения:
1) Все транзакции должны быть маленькими и быстрыми, поскольку одна большая транзакция может заблокировать выполнение
   всех остальных
2) Набор данных желательно должен умещаться в память целиком для более быстрого выполнения транзакций
3) Пропускная способность по записи должна быть низкой для обработки на одном ядре CPU
4) Многосекционные транзакции возможны, но имеют свои подводные камни

#### Двухфазная блокировка (2PL)
В течение 30 лет в БД широко используется именно этот алгоритм сериализуемости.

Двухфазная блокировка допускает конкурентное чтение одного объекта несколькими транзакциями, при условии, что его никто
не записывает. Но для выполнения записи объекта требуется монопольный доступ.
- Если транзакция A читает объект, а транзакция Б хочет выполнить его запись, то Б должна дождаться фиксации или
  прерывания транзакции А.
- Если транзакция А записывает объект, а транзакция Б хочет его прочитать, то она должна дождаться фиксации или
  прерывания транзакции Б.

Чтоб реализовать такое, в каждом объекте БД имеется блокировка, которая может быть разделяемой (shared mode) или
монопольной (exclusive mode). Эти блокировки применяются следующим образом:
- Перед чтением транзакция устанавливает блокировку в разделяемом режиме. Если до этого какая-то транзакция установила
  монопольную блокировку, то разделяемой придется подождать ее завершения. Допускается удержание блокировки в разделяемом
  режиме несколькими транзакциями одновременно.
- Перед записью транзакция должна установить блокировку в монопольном режиме. Никаким другим транзакциям не разраешается
  одновременно с ней удерживать блокировку. Если на объекте уже есть блокировка, новой монопольной придется подождать.
- При чтении с последющей записью можно повышать уровень блокировки с разделяемой до монопольной. Такое повышение
  выполняется аналогично последовательному занятию блокировки.
- После установки блокировки транзакция удерживает ее вплоть до завершения. Отсюда и название двухфазная: первая фаза -
  захват блокировок. Вторая фаза - освобождение.

Транзакции могут взаимно заблокировать друг друга (deadlock), но БД автоматически это замечает и прерывает одну из
транзакций.

Главный недостаток двухфазной блокировки - ее производительность. Слабые блокировки намного быстрее двухфазной. Главная
ее проблема в пессимистичном управлении транзакциями. Если две транзакции теоретически могут привести к состоянию гонки,
то одна из них останавливается. Если одна из транзакций окажется неоправданно долгой, то другая будет заблокирована на
все время выполнения. Поэтому время ожидания в 2PL базах способно меняться в достаточно широких пределах и на верхних
перцентилях они могут работать достаточно долго.

Двухфазная блокировка нередко может включать в себя предикатную блокировку - разделяемая/монопольная блокировка не на
объект, а на множество удовлетворяющее некоторому условию. Такая двухфазная блокировка предотвращает все формы
асимметрии записи и других состояний гонки, так что такую изоляцию можно назвать сериализованной.

К сожалению производительность предикатной блокировки оставляет желать лучшего, поэтому большинство баз на самом деле
реализовывают блокировку по диапазону значений индекса. Если необходимого индекса нет, то используется просто предикатная
блокировка по значению.

#### Сериализуемая изоляция снимков состояния (SSI)
Молодой метод сериализуемости (появился в 2008 году), используется в одноузловых PostgreSQL базах.

Сериализуемая изоляция снимков состояния (SSI) представляет собой оптимистичный подход к управлению транзакциями. Вместо
блокировки потенциально опасных транзакций они выполняются конкурентно, в надежде что не помешает друг другу. При
фиксации транзакций БД проверяет, не произошло ли чего-нибудь плохого. Если произошло, одна из транзакций прерывается и
ее выполнение приходится повторять еще раз. Как правило, данный подход работает быстро, но если в системе сильная
конкуренция для одних и тех же данных, то производительность метода может пострадать, так как приходится прерывать и
повторять большой процент транзакций.

Для проверки транзакции перед фиксацией есть 2 способа:
1) Выявление операций чтения устаревших снимков MVCC - во время фиксации база проверяет, были ли зафиксированы
   проигнорированные снимки MVCC. Если были - транзакция откатывается.
2) Выявление операций записи, влияющих на предшествующие операции чтения - транзакция записывающая данные проверяет, читал
   ли кто-нибудь предыдущие снимки измененных данных. Если читал, то такая транзакция откатывается.

## Резюме
Существуют следующие проблемы изоляций транзакции:
1) Грязные чтения - чтение записанных данных до их фиксации. Чинит уровень `Read commited`
2) Невоспроизводимое чтение - чтение одних и тех же данных дважды может быть неодинаковым. Чинит 
`Repeatable read` при помощи MVCC механизма.
3) Потерянные обновления - одна транзакция перезаписывает изменения другой транзакции. 
4) Асимметрия записи - транзакция читает данные, принимает на их основе решение и производит запись. Однако на момент
записи прочитанные данные изменились и запись была неправомерна. Решает только сериализуемость.
5) Фантомные чтения - одна транзакция при повторном запросе получает разные данные, потому что другая транзакция 
вставила данные. Решает только сериализуемость.

Для решения этих проблем существуют слабые уровни изоляции (read commited, repeatable read и serialized). Сериализуемость
может быть реализована следующими способами (последовательное выполнение, двухфазная блокировка, сериализуемая
изоляция снимков).
