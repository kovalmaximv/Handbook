# Domain Driven Design (DDD)
Состоит из 3х принципов: 
- Ограниченные контексты (bounded context)
- Единый язык (ubiquitous language)
- Фокус на доменной модели

# Ограниченный контекст
DDD вводит понятие **problem space**. Problem space это задача, которую решает бизнес. Например, есть магазин, его problem 
space это продажа товаров. В рамках problem space выделяют **subdomain**, это какие-то более мелкие бизнес процессы. 
Например, в магазине subdomain могут быть: продажа товаров и услуг, поддержка, доставка и тд.

Для каждого subdomain на уровне кода создается **ограниченный контекст**. Ограниченный контекст это логическое 
разделение используемых моделей. Например, в рамках сабдомена продажи в ограниченном контексте находятся понятия: 
клиент, товар, территория продажи, продавец. В рамках сабдомена поддержки находятся понятия: клиент, товар, дефект.

Обратите внимание, что понятия в разных ограниченных контекстах могут пересекаться, это нормально и иначе, как правило, 
не бывает. DDD говорит, что в таких случаях сущности надо копировать и держать в двух местах. Фактически это будут две
таблицы или даже две разные базы. На самом деле это имеет смысл, потому что оба сабдомена рассматривают эти понятия 
иначе и могут добавлять к понятию специфические аттрибуты. Например, сабдомен поддержки может ввести аттрибут "уровень
поддержки" (золотой/серебряный/бронзовый), который не интересен домену продаж. Тем не менее у каждого аттрибута должен
быть мастер сабдомен. Изменять атрибут разрешается только в рамках его мастер сабдомена. Это необходимо, потому что 
если аттрибут будут пытаться одновременно изменить в нескольких доменах, то будет необходимо как-то мержить эти изменения.

# Единый язык
Единый язык на самом деле является частью ограниченного контекста. Единый язык необходим, чтобы разработчик и бизнес 
эксперт говорили на одном языке. Кодовая база должна отражать все сущности бизнеса: если в рамках бизнес процессов есть
покупать (customer), то такая сущность обязательно должна быть в базе, то же самое с различными документами и отчетами.
Сервисы должны по возможности повторять названия бизнес процессов. Таким образом код, написанный по DDD, является
самодокументированным. Достаточно почитать хороший код, чтобы понять, как работает бизнес. Разработчик тут является 
медиатором между доменной логикой в коде (domain model) и бизнес экспертами. Такой подход требует постоянного рефакторинга и 
синхронизации с бизнес экспертами, чтобы все были на одной волне. 

Конечная точка единого языка - DSL (domain specific language). Когда мы пишем код, даже следуя единому языку, у нас 
получается что-то типа `public class Customer {...}`. Ключевые слова языка Java только мешают единому пониманию кодовой
базы со стороны бизнес экспертов. Если развивать единый язык дальше, то разрабатывается собственный язык, чтобы 
сущность в коде можно было описать просто как `Customer {...}`, так же по аналогии с другими сущностями и бизнес 
процессами. Однако это очень дорого и почти никто не идет на такой шаг. 

# Фокус на доменной модели
Зачастую при разработке новых приложений применяется inside-out development. Это когда мы сначала проектируем базу 
данных и таблицы в ней. Потом на основе этого делаем слой data access, затем слой business logic, слой API и тд. 
DDD говорит, что так делать не надо и предлагает подход middle-out development. При таком подходе сначала 
разрабатывается доменная логика, а все остальные слои строятся поверх. Идея в том, что core domain 
model меняться будет крайне редко, если бизнес продает корм для собак, вряд ли через пару лет он будет производить 
автомобили. А вот все последующие слои будут меняться чаще. Даже изменение базы данных или других основных технологий 
более реалистично, чем изменение core domain model.

Так же нужно следить, чтобы доменная логика не размазывалась по всем слоям приложения. Потом с этой логикой становится 
очень сложно работать. Будет практически невозможно знать про все нюансы доменной логики и малейшие изменения могут 
стать проблемой.

Коробочные решения - яркий пример отсутствия фокуса на доменной модели. Если их применять в core domain model, то 
продукту будет сложно получить конкурентные преимущества. Дело в том, что коробочное решение почти наверняка не будет 
иметь то, что необходимо именно вашему бизнесу, зато будет иметь большое количество того, что не нужно вашему бизнесу.
Например, у вас в домене есть сущность розничный покупать, а в коробочном решении такого понятия нет, но есть 
ключевой бизнес партнер. Вам придется использовать эту сущность, за неимением альтернатив. Если несколько раз принять
такие решения, доменная логика станет сложной и запутанной. Вносить в нее изменения будет сложно. Использовать коробочные
решения можно в generic доменных областях. Например, для интернет-магазина это ведение бух учета сотрудника. 
Разрабатывать собственное решение тут будет странно, поэтому можно просто использовать 1С. 

# Источники
1) Владимир Хориков — Domain-driven design: Cамое важное. https://www.youtube.com/watch?v=JOy_SNK3qj4