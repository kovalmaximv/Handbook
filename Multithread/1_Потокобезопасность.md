# Потокобезопасность
У каждого объекта есть _состояние_, это какие-то данные, которые хранятся в переменных. 
Если это состояние мутируемое (может быть изменено) и к нему обращаются из нескольких потоков, 
то такое состояние не _потокобезопасно_.

> Всякий раз, когда более чем один поток обращается к переменной состояния, а другой из потоков в 
> нее пишет, все потоки должны координировать свой доступ к ней с помощью синхронизации.

Если многочисленные потоки обращаются к одной мутируемой переменной без синхронизации, то программа неисправна.
Существует 3 способа ее исправить:
1) Не использовать переменную состояния совместно во всех потоках
2) Сделать переменную немутируемой
3) При каждом доступе к переменной использовать синхронизацию

> Класс является потокобезопасным, если он ведет себя правильно во время доступа из многочисленных потоков, 
> независимо от того, как выполнение этих потоков перемежается между собой.

### Пример
Есть некоторый класс, выполняющий разложение числа на его множители. Этот класс может вызываться во 
многопоточной среде.

```java
@ThreadSafe
public class NumFactor {
    public long[] service(long number){
        return factor(number);
    }
}
```

Такой класс является потокобезопасным, так как он не имеет внутреннего состояния: не содержит полей и 
не ссылается на поля из других классов. Состояния для конкретного вызова существует только в локальных 
переменных потока и доступны для изменения только ему. :exclamation:

> :exclamation: **Объекты без внутреннего состояния всегда являются потокобезопасными.**