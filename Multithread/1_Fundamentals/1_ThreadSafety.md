# Потокобезопасность
У некоторых объектов есть данные, хранящиеся в переменных. Эти данные называются _состоянием_. 
Если это состояние мутируемое (может быть изменено) и к нему могут обращаться несколько потоков, 
то такое состояние не _потокобезопасно_.

> :exclamation: **Если одни потоки читают переменную состояния, а другие потоки в 
> неё пишут, то все эти потоки должны координировать свой доступ к данным с помощью синхронизации.**

Если многочисленные потоки обращаются к одной мутируемой переменной без синхронизации, то программа неисправна.
Существует 3 способа это исправить:
1) Не использовать переменную состояния совместно во всех потоках
2) Сделать переменную немутируемой
3) При каждом доступе к переменной использовать синхронизацию

> :exclamation: **Класс является потокобезопасным, если его использование в многопоточной среде не вызывает ошибок.**

#### Пример
Есть некоторый класс, выполняющий разложение числа на его множители. Этот класс может вызываться во 
многопоточной среде.

```java
@ThreadSafe
public class NumFactor {
    public long[] service(long number){
        return factor(number);
    }
}
```

Такой класс является потокобезопасным, так как он не имеет внутреннего состояния: не содержит полей и 
не ссылается на поля из других классов. Состояния для конкретного вызова существует только в локальных 
переменных потока и доступны для изменения только ему.

> :exclamation: **Объекты без внутреннего состояния всегда являются потокобезопасными.**

## Атомарность
> :exclamation: **Атомарная операция - операция, частичное выполнение которой невозможно.**

Операция атомарна, если она выполняется как бы мгновенно, за один такт процессора. Невозможно застать атомарную 
операцию в частично выполненном состоянии. Она может быть либо еще не выполнена, либо уже выполнена.

Предположим, что мы хотим добавить счетчик обращений в наш пример выше.

```java
@NotThreadSafe
public class NumFactor {
    private long counter = 0;
    
    public long[] service(long number){
        ++counter;
        return factor(number);
    }
}
```

Теперь класс `NumFactor` не является потокобезопасным, так как приращение счетчика не атомарно.  
При увеличении счетчика происходит 3 действия: достать текущее значение, прибавить единицу, положить его обратно.

Если два потока попробуют одновременно увеличить такой счетчик, то оба потока достанут значение 0, 
добавят к нему 1, и положат значение 1 обратно. Таким образом мы потеряем один вызов в счетчике.

![counter_example.png](../../img/multithread/counter_example.png)

Данная проблема называется состоянием гонки (_race condition_).

## Race condition
> :exclamation: **Состояние гонки - ошибка проектирования, при которой результат кода не детерминирован и зависит от 
> порядка выполнения частей кода, которые не синхронизированы должным образом.**

Состояние гонки возникает, когда один и тот же ресурс используется несколькими потоками одновременно, и в 
зависимости от порядка действий каждого потока может быть несколько возможных результатов.

Очень часто состоянием гонки появляется при использовании подхода "проверить и затем действовать". Большинство 
состояний гонки вызывают неожиданные исключения, перезаписанные данные, повреждения файла и др.

Примером состояния гонки является _ленивая инициализация_. 
Ее цель - отложить инициализацию "тяжелого" объекта до тех пор, пока он не понадобится и обеспечить, чтобы 
он инициализировался только один раз.

```java
@NotThreadSafe
public class LazyInitRace {
    private ExpensiveObject instance = null;
    
    public ExpensiveObject getInstance() {
        if (instance == null) {
            instance = new ExpensiveObject();
        }
        return instance;
    }
}
```

Предположим, что несколько потоков выполняют метод `getInstance` одновременно. Они оба увидят, 
что `instance == null` и оба начнут создавать тяжелый объект. Таким образом два вызова вернут два разных объекта,
еще и создадут его дважды, что противоречит задачи класса. 

## Atomic переменные
> :exclamation: **Операции "проверить и затем действовать" и "прочитать, изменить, записать" 
> всегда должны быть атомарными.**

Атомарность позволяет избежать проблемы со счетчиком в примере `NumFactor`.

```java
@ThreadSafe
public class NumFactor {
    private AtomicLong counter = new AtomicLong(0);

    public long[] service(long number) {
        counter.incrementAndGet();
        return factor(number);
    }
}
```

Пакет `java.util.concurrent.atomic` содержит атомарные переменные, они позволяют проводить над ними 
атомарные операции. В данном случае это помогло нам произвести действие "прочитать, изменить, записать" атомарно.

## Блокировка
Расширим наш пример, допустим мы хотим кешировать последний результат, для увеличения быстродействия.

```java
@NotThreadSafe
public class CachingNumFactor {
    private final AtomicReference<Long> lastNumber = new AtomicReference<>();
    private final AtomicReference<Long[]> lastFactors = new AtomicReference<>();
    
    public Long[] service(Long number) {
        if (number.equals(lastNumber.get())) {
            return lastFactors.get();
        } else {
            Long[] factors = factor(number);
            lastNumber.set(number);
            lastFactors.set(factors);
            return factors;
        }
    }
}
```

Такой класс не является потокобезопасным, он содержит _состояние гонки_. 
В нашем случае, состояние объекта зависит от двух изменяемых переменных и они зависимыми друг от друга. Между изменением 
`lastNumber` и `lastFactors` есть окно, во время которого один поток может смешать данные другого. Эти переменные
должны обновляться _атомарно_.

> :exclamation: **Для сохранения непротиворечивости состояния обновляйте родственные переменные в единой атомарной операции.**

#### Внутренние замки
В Java есть встроенный механизм для синхронизации блока кода (synchronized), состоящий из ссылки на объект-замок (lock) и блока кода.

```java
synchronized(lock) {
    // smth    
}
```

Каждый объект в Java может служить замком для такого блока, то есть может являться _мониторным замком_(monitor lock).  

Замок автоматически приобретается выполняющим потоком перед входом в синхронизированный блок и автоматически 
освобождается, когда управление выходит за блок (обычным выполнением или исключением). Приобрести замок можно только 
при входе в синхронизированный блок или в синхронизированный метод.

Замки в Java действуют как _мьютексы_ (mutual exclusion lock, взаимоисключающие замки). Это означает, что замком может 
владеть только один поток. Когда поток A пытается приобрести замок, которым владеет поток B, он будет ждать до тех пор, 
пока поток B не освободит замок. 

Поскольку только один поток за раз может выполнять блок кода, защищенный замком, то синхронизированные 
блоки с одним замком, выполняются атомарно.

Используя наши знания, мы можем починить `CachingNumFactor`:
```java
@ThreadSafe
@BadPerformance
public class SynchronizedCachingNumFactor {
    private final AtomicReference<Long> lastNumber = new AtomicReference<>();
    private final AtomicReference<Long[]> lastFactors = new AtomicReference<>();
    
    public synchronized Long[] service(Long number) {
        if (number.equals(lastNumber.get())) {
            return lastFactors.get();
        } else {
            Long[] factors = factor(number);
            lastNumber.set(number);
            lastFactors.set(factors);
            return factors;
        }
    }
}
```
Такой код является потокобезопасным, но по сути, он стал синхронным, поскольку весь метод может выполнять только 
один поток за раз. Намного лучше, особенно при наличии тяжелых операций, выделять минимальные синхронизированные блоки.

Если в примере `SynchronizedCachingNumFactor` изменить видимость переменных на public, то класс снова станет не
потокобезопасным. **Приобретение ассоциированного с объектом замка _не_ препятствует тому, чтобы другие потоки обращались
к этому объекту.** Единственное, что приобретение замка не дает сделать другому потоку - приобрести тот же самый замок.
Таким образом, если изменить видимость на public, то другой поток запросто может обратиться к переменной и изменить ее.

Замки в Java так же являются повторно входимыми (reetrant), если поток пытается приобрести замок, которым он уже владеет, 
то запрос выполнится успешно. Повторная входимость означает, что замок приобретается в расчете на поток, а не на вызов.
У каждого замка есть счетчик приобретений и владелец замка. При приобретении замка тем же владельцем, поток 
увеличивается на 1, при освобождении поток уменьшается на 1. Замок освобождается, когда поток равен 0.

Распространенная ошибка, что синхронизация должна использоваться только во время записи. **Все обращения к мутируемой 
переменной состояния должны выполняться с использованием одного и того-же замка.**

