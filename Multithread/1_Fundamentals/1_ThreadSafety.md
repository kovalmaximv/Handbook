# Потокобезопасность
У каждого объекта есть _состояние_, это какие-то данные, которые хранятся в переменных. 
Если это состояние мутируемое (может быть изменено) и к нему обращаются из нескольких потоков, 
то такое состояние не _потокобезопасно_.

> :exclamation: **Всякий раз, когда некоторые потоки читают переменную состояния, а другие потоки в 
> неё пишут, все потоки должны координировать свой доступ к ней с помощью синхронизации.**

Если многочисленные потоки обращаются к одной мутируемой переменной без синхронизации, то программа неисправна.
Существует 3 способа это исправить:
1) Не использовать переменную состояния совместно во всех потоках
2) Сделать переменную немутируемой
3) При каждом доступе к переменной использовать синхронизацию

> :exclamation: **Класс является потокобезопасным, если он ведет себя правильно во время доступа из многочисленных потоков, 
> независимо от того, как выполнение этих потоков перемежается между собой.**

#### Пример
Есть некоторый класс, выполняющий разложение числа на его множители. Этот класс может вызываться во 
многопоточной среде.

```java
@ThreadSafe
public class NumFactor {
    public long[] service(long number){
        return factor(number);
    }
}
```

Такой класс является потокобезопасным, так как он не имеет внутреннего состояния: не содержит полей и 
не ссылается на поля из других классов. Состояния для конкретного вызова существует только в локальных 
переменных потока и доступны для изменения только ему.

> :exclamation: **Объекты без внутреннего состояния всегда являются потокобезопасными.**

## Атомарность
Предположим, что мы хотим добавить счетчик обращений в наш пример выше.

```java
@NotThreadSafe
public class NumFactor {
    private long counter = 0;
    
    public long[] service(long number){
        ++counter;
        return factor(number);
    }
}
```

Теперь класс `NumFactor` не является потокобезопасным, так как приращение счетчика не атомарно.  
При увеличении счетчика происходит 3 действия: достать текущее значение, прибавить единицу, положить его обратно.

Если два потока попробуют одновременно увеличить такой счетчик, то оба потока достанут значение 0, 
добавят к нему 1, и положат значение 1 обратно. Таким образом мы потеряем один вызов в счетчике.

![counter_example.png](../../img/multithread/counter_example.png)

Данная проблема называется состоянием гонки (_race condition_).

## Race condition
Очень частым типом состоянием гонки является подход "проверить и затем действовать". Большинство 
состояний гонки вызывают неожиданные исключения, перезаписанные данные, повреждения файла и др.

Мы часто сталкиваемся с состоянием гонки в реальной жизни.  

Допустим вы договорились встретиться с другом в 12 в кофейне в ТЦ. В условленное время вы пришли в кофейню, 
но друга там нет. Вы вспоминаете, что в ТЦ есть две кофейни и решили сходить проверить другую. Вы не знаете, 
пришел ли ваш друг или нет, возможно вы ходите кругами друг за другом и отправляетесь обратно. В худшем 
варианте развития событий вы, таким образом, будете ходить друг за другом целый день.

Проблема "прогуляться и посмотреть другую кофейню" заключается в том, что прогулка занимает время, за которое 
система может измениться.

Примером подобной проблемы в программирование является _ленивая инициализация_. 
Ее цель - отложить инициализацию "тяжелого" объекта до тех пор, пока он не понадобится и обеспечить, чтобы 
он инициализировался только один раз.

```java
@NotThreadSafe
public class LazyInitRace {
    private ExpensiveObject instance = null;
    
    public ExpensiveObject getInstance() {
        if (instance == null) {
            instance = new ExpensiveObject();
        }
        return instance;
    }
}
```

Предположим, что несколько потоков выполняют метод `getInstance` одновременно. Они оба увидят, 
что `instance == null` и оба начнут создавать тяжелый объект. Таким образом два вызова вернут два разных объекта,
еще и создадут его дважды, что противоречит задачи класса. 

## Atomic переменные
Оба наших примера выше содержат операции, которые должны быть атомарными.

> :exclamation: **Операция в общей области памяти называется атомарной, если она завершается в один шаг относительно других потоков,
имеющих доступ к этой памяти. Во время выполнения такой операции над переменной, ни один поток не может наблюдать
изменение наполовину завершенным.**

Удобно думать об атомарной операции, как об операции, что выполняется за один тик процессора. 
Во время выполнения такой операции никакой другой поток не может помешать выполнению, так как тик - 
минимальная неделимая вычислительная операция процессора.

> :exclamation: **Операции "проверить и затем действовать" и "прочитать, изменить, записать" 
> всегда должны быть атомарными.**

Атомарность позволяет избежать проблемы со счетчиком в примере `NumFactor`.

```java
import java.util.concurrent.atomic.AtomicLong;

@ThreadSafe
public class NumFactor {
    private AtomicLong counter = new AtomicLong(0);

    public long[] service(long number) {
        counter.incrementAndGet();
        return factor(number);
    }
}
```

Пакет `java.util.concurrent.atomic` содержит атомарные переменные, они позволяют проводить над ними 
атомарные операции. В данном случае это помогло нам произвести действие "прочитать, изменить, записать" атомарно.

## Блокировка
Расширим наш пример, допустим мы хотим кешировать последний результат, для увеличения быстродействия.

```java
import java.util.concurrent.atomic.AtomicReference;

@NotThreadSafe
public class CachingNumFactor {
    private final AtomicReference<Long> lastNumber = new AtomicReference<>();
    private final AtomicReference<Long[]> lastFactors = new AtomicReference<>();
    
    public Long[] service(Long number) {
        if (number.equals(lastNumber.get())) {
            return lastFactors.get();
        } else {
            Long[] factors = factor(number);
            lastNumber.set(number);
            lastFactors.set(factors);
            return factors;
        }
    }
}
```

Такой класс не является потокобезопасным, он содержит _состояние гонки_. 
В нашем случае, состояние объекта зависит от двух изменяемых переменных и они зависимыми друг от друга. Между изменением 
`lastNumber` и `lastFactors` есть окно, во время которого один поток может смешать данные другого. Эти переменные
должны обновляться _атомарно_.

> :exclamation: **Для сохранения непротиворечивости состояния обновляйте родственные переменные в единой атомарной операции.**

## Внутренние замки
В Java есть встроенный механизм для синхронизации блока кода (synchronized), состоящий из ссылки на объект-замок (lock) и блока кода.

```java
synchronized(lock) {
    // smth    
}
```

Каждый объект в Java может служить замком для такого блока, то есть может являться _мониторным замком_(monitor lock).  

Замок автоматически приобретается выполняющим потоком перед входом в синхронизированный блок и автоматически 
освобождается, когда управление выходит за блок (обычным выполнением или исключением). Приобрести замок можно только 
при входе в синхронизированный блок или в синхронизированный метод.

Замки в Java действуют как _мьютексы_ (mutual exclusion lock, взаимоисключающие замки). Это означает, что замком может 
владеть только один поток. Когда поток A пытается приобрести замок, которым владеет поток B, он будет ждать до тех пор, 
пока поток B не освободит замок. 

Поскольку только один поток за раз может выполнять блок кода, защищенный замком, то синхронизированные 
блоки с одним замком, выполняются атомарно.

Используя наши знания, мы можем починить `CachingNumFactor`:
```java
import java.util.concurrent.atomic.AtomicReference;

@ThreadSafe
@BadPerformance
public class SynchronizedCachingNumFactor {
    private final AtomicReference<Long> lastNumber = new AtomicReference<>();
    private final AtomicReference<Long[]> lastFactors = new AtomicReference<>();
    
    public synchronized Long[] service(Long number) {
        if (number.equals(lastNumber.get())) {
            return lastFactors.get();
        } else {
            Long[] factors = factor(number);
            lastNumber.set(number);
            lastFactors.set(factors);
            return factors;
        }
    }
}
```
Такой код является потокобезопасным, но по сути, он стал синхронным, поскольку весь метод может выполнять только 
один поток за раз. Намного лучше, особенно при наличии тяжелых операций, выделять минимальные синхронизированные блоки.

Если в примере `SynchronizedCachingNumFactor` изменить видимость переменных на public, то класс снова станет не
потокобезопасным. **Приобретение ассоциированного с объектом замка _не_ препятствует тому, чтобы другие потоки обращались
к этому объекту.** Единственное, что приобретение замка не дает сделать другому потоку - приобрести тот же самый замок.
Таким образом, если изменить видимость на public, то другой поток запросто может обратиться к переменной и изменить ее.

Замки в Java так же являются повторно входимыми (reetrant), если поток пытается приобрести замок, которым он уже владеет, 
то запрос выполнится успешно. Повторная входимость означает, что замок приобретается в расчете на поток, а не на вызов.
У каждого замка есть счетчик приобретений и владелец замка. При приобретении замка тем же владельцем, поток 
увеличивается на 1, при освобождении поток уменьшается на 1. Замок освобождается, когда поток равен 0.

Распространенная ошибка, что синхронизация должна использоваться только во время записи. **Все обращения к мутируемой 
переменной состояния должны выполняться с использованием одного и того-же замка.**

