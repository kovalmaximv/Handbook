# Отмена и выключение

Иногда нам требуется останавливать задачи и потоки раньше, чем они завершатся сами. В Java нет механизма 
принудительной остановки работы потока, но есть механизм _прерывания_ (interruption) - кооперативный механизм, 
который позволяет одному потоку попросить другой прекратить действовать.

Мы редко хотим, чтобы поток останавливался немедленно и бросал свое состояние в противоречивом состоянии. Избежать 
этой проблемы помогает механизм прерывания. Этот механизм так же обеспечивает большую гибкость, потому что задачный 
код лучше знает, что нужно сделать перед отменой потока. Запрашивающий отмену код может не владеть такой информацией. 

В этой главе описываются механизмы отмены (cancellation) и прерывания (interruption) и способы кодирования задач и 
служб, откликающихся на запросы об отмене.

## Отмена задачи
В этом параграфе обсудим отмену Runnable и Callable задач.

Задача, задуманная как отменяемая, должна иметь политику отмены:
1) Как другой код может запросить отмену
2) Когда задача проверяет наличие запроса на отмену
3) Какие действия задача предпринимает на запрос об отмене

Попробуем написать механизм отмены задачи, начиная с самого простого решения, с каждым разом будем немного 
улучшать решение. 

#### Флаг "запрошена отмена"

Самым простейшим механизмом отмены является установка флажка "запрошена отмена", который задача периодически проверяет. 
Рассмотрим пример такого подхода:

```java
public class PrimeGenerator implements Runnable {
    private final List<BigInteger> primes = new ArrayList<>();
    private volatile boolean cancelled; 
    
    public void run() {
        BigInteger p = BigInteger.ONE;
        while (!cancelled) {
            p = p.nextProbablePrime();
            synchronized (this) {
                primes.add(p);
            }
        }
    }
    
    public void cancel() {
        cancelled = true;
    }
    
    public synchronized List<BigInteger> get() {
        return new ArrayList<>(primes);
    }
}
```

#### Прерывание
Если задача использует блокирующие метода (напр. BlockingQueue.put), то такая проверка может ни разу не сработать и 
задача не отменится (поскольку поток выполнения заблокирован).

В таких случаях стоит использовать _прерывание_, блокирующие библиотечные методы поддерживают прерывание.

Каждый поток имеет флаг прерванности (interrupted status). Объект Thread содержит метод _interrupt_, прерывающий поток, 
метод _isInterrupted_, возвращающий флаг прерванности. Очистить статус прерванности можно статическим методом 
_interrupted_.
```java
public class Thread {
    public void interrupt() {...}
    public void isInterrupted() {...}
    public static boolean interrupted() {...}
}
```

> :exclamation: **Метод interrupt не побуждает целевой поток остановиться, он только доставляет сообщение с 
> просьбой остановки при удобной возможности.**

Блокирующие библиотечные методы (BlockingQueue.put, Thread.sleep, etc) быстро отзываются на прерывание, очищают
статус прерванности и выдают исключение InterruptedException. 

Очищение статуса прерванности следует использовать осторожно. Если вы не планируете проигнорировать прерывание, то 
нужно либо восстановить статус прерванности (вызвав метод interrupt), либо выкинуть исключение InterruptedException.

> :exclamation: **Прерывание является самым разумным способом отмены.**

Попробуем улучшить наш генератор простых чисел с использованием прерывания:

```java
public class PrimeGenerator implements Runnable {
    private final BlockingQueue<BigInteger> primes;

    public PrimeGenerator(BlockingQueue<BigInteger> primes) {
        this.primes = primes;
    }
    
    public void run() {
        try {
            BigInteger p = BigInteger.ONE;
            while (!Thread.currentThread().isInterrupted()) {
                primes.put(p.nextProbablePrime());
            } catch(InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }

    public void cancel() {
        interrupt();
    }
}
```

В примере выше есть две точки обнаружения прерывания. Явная проверка в условии цикла не является строго необходимой, 
но позволяет произвести проверку _перед_ тяжелой операцией подсчета следующего простого числа. 

#### Политика прерывания
Потокам необходима политика прерывания, определяющая, как они интерпретируют запросы на прерывание.

Важно различать, как _задачи_ и _потоки_ должны откликаться на прерывание.

Код, который не является владельцем потока, должен сохранять статус прерванности. 
Таким образом, с прерыванием потока придется разбираться владельцу этого потока, а он наверняка знает лучше, 
как прервать этот поток.

Получается, что задача никак не может прервать поток. Она может или сохранить статус прерванности, проигнорировав его, 
либо выкинуть исключение InterruptedException. И в первом, и во втором случае с прерыванием будет разбираться владелец 
потока.

#### Обработка InterruptedException
Существуют две стратегии:
1) Распространение исключение выше по стеку (throws InterruptedException)
2) Восстановление статуса прерванности (Thread.currentThread().interrupt())

> :exclamation: **Нельзя проглатывать исключение, если ваш код не реализует политику прерывания для потока.**

Если по какой-то причине задача не поддерживает отмену, то можно вызывать блокирующий метод в цикле, повторяя 
попытки вызова. Главное не забыть вернуть статус прерванности в конце выполнения задачи:
```java
public Task getNextTask(BlockingQueue<Task> queue) {
    boolean interrupted = false;
    try {
        while (true) {
            try {
                return queue.take();
            } catch (InterruptedException e) {
                interrupted = true; // Проскочить и попытаться снова
            }
        }
    } finally {
        if (interrupted) {
            Thread.currentThread().interrupt();
        }
    }
}
```

Если ваш код не вызывает блокирующие методы, то он может отзываться на прерывание путем опроса статуса прерванности:
```java
if (Thread.currentThread().isInterrupted()) {...}
```

#### Пример: хронометрированный прогон (а этот пример вообще нужен?)