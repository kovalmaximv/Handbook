# Выполнение задач
Большинство конкурентных приложений выполняют некоторые параллельные задачи. Разделение работы приложения на 
задачи упрощает проектирование и структуру многопоточных приложений.

## Выполнение задач в потоках
Первое, что стоит сделать, четко определить границы задач. Независимые друг от друга задачи могут выполняться 
параллельно. 

Большинство серверных приложений в качестве границы одной задачи предлагают индивидуальные клиентские запросы. Сервер
принимает запрос от удаленных клиентов, обрабатывают их одновременно и независимо друг от друга.

В этой главе мы будем в качестве примера разрабатывать каркас веб сервера. Рассмотрим пример последовательной 
обработки запроса

```java
import java.net.ServerSocket;

class SingleThreadServer {
    public static void main(String[] args) {
        ServerSocket server = new ServerSocket(80);
        while (true) {
            Socket connection = server.accept();
            handleRequest(connection);
        }
    }
}
```

#### Явное создание потоков для задач
Сделаем наш веб сервер многопоточным

```java
class ThreadPerTaskWebServer {
    public static void main(String[] args) {
        ServerSocket server = new ServerSocket(80);
        while (true) {
            final Socket connection = server.accept();
            Runnable task = () -> handleRequest(connection);
            new Thread(task).start();
        }
    }
}
```

Главный поток принимает новый запросы и создает под каждый запрос отдельный поток, который обработает этот запрос. 
Благодаря этому:
- Главный цикл может принимать новый запрос до того, как обработается старый
- Задачи обрабатываются параллельно, увеличивая пропускную способность
- Возрастает необходимость потокбезопасности кода

При этом такой подход имеет свои недостатки:

- Создание потоков занимает время и мощности, гораздо выгоднее переиспользовать уже созданные потоки
- Существует лимит на кол-во создаваемых потоков

Сначала увеличения числа потоков повышает пропускную способность, но начиная с определенного момента большое кол-во 
потоков начинает замедлять работу приложения и может привести к сбоям.

#### Executor
Ряд преимуществ предоставляют поточные пулы (thread pools), Java предоставляет их гибкую реализацию в классе Executor.

Основным классом для выполнения задач является не Thread, а Executor:
```java
public interface Executor {
    void execute(Runnable command);
}
```
Таким образом, Executor разделяет предоставление задачи (Executor) от ее выполнения (Runnable).
Отделение предоставления задачи от ее выполнения позволяет легко определить и изменить политику выполнения для 
выбранного класса задач. 

Спецификация политики выполнения отвечает на вопросы:
1) В каком потоке будут выполняться задачи
2) Какой порядок выполнения задач
3) Сколько задач может выполняться конкурентно
4) Сколько задач может быть поставлено в очередь
5) Как система должна себя вести при перегрузке


Попробуем написать веб сервер с использованием Executor
```java
class TaskExecutionWebServer {
    private static final int NUMBER_THREADS = 100;
    private static final Executor executor = Executors.newFixedThreadPool(NUMBER_THREADS);

    public static void main(String[] args) {
        ServerSocket server = new ServerSocket(80);
        while (true) {
            final Socket connection = server.accept();
            Runnable task = () -> handleRequest(connection);
            executor.execute(task);
        }
    }
}
```

Сервер использует Executor с ограниченным пулом рабочих потоков. Предоставление задачи с помощью execute добавляет 
задачу в рабочую очередь, а рабочие непрерывно выполняют задачи, удаляя их из очереди.

#### Пулы потоков
Пул потоков тесно привязан к рабочей очереди (_work queue_), содержащей задачи, необходимые для выполнения. Рабочие 
потоки берут задачу из очереди, выполняют ее и возвращаются к ожиданию следующей задачи из очереди.

Многоразовое использование существующего потока избавляет от затрат на создание отдельных потоков. Правильно настроив
размер пула потоков можно равномерно загрузить процессор и сохранить ресурсы.

Библиотека Executors в Java позволяет гибко настроить пул потоков:
1) **newFixedThreadPool** - пул потоков фиксированного размера. Задает максимум потоков, которые могут быть 
использованы для обработки задач. Если поток был закрыт (например из-за ошибки), будет создан новый поток. Поток в пуле 
будет жить, пока не будет вызван shutdown.
2) **newCachedThreadPool** - пул использует свободный поток для выполнения задачи, если свободного потока нет, создает 
новый и добавляет в пул. Неиспользуемые (в течении 60 сек) потоки закрываются и удаляются из пула. 
Данный пул потоков не накладывает ограничение на максимальное кол-во потоков в пуле.
3) **newSingleThreadPool** - пул использует один поток для выполнения задач, задачи выполняются строго последовательно в 
порядке добавления. Если поток из-за ошибки в задаче был завершен, создастся новый поток. Отличие от 
newFixedThreadPool(1) в том, что newSingleThreadPool гарантированно не может быть переконфигурирован для использования
дополнительных потоков.
4) **newScheduledThreadPool** - пул фиксированного размера, который поддерживает отложенный старт или периодическое
выполнения задач. 

newFixedThreadPool и newCachedThreadPool возвращают ThreadPoolExecutor, который может быть дополнительно конфигурирован.  

#### Завершение работы Executor
JVM ждет окончания всех процессов, поэтому если Executor по какой-то причине не может завершиться, это не позволяет
JVM завершить работу.

Интерфейс ExecutorService расширяет интерфейс Executor добавляя возможность управления жизненным циклом:

```java
public interface ExecutorService extends Executor {
    void shutdown();
    List<Runnable> shutdownNow();
    boolean isShutdown();
    boolean isTerminated();
    boolean awaitTermination(long timeout, TimeUnit unit);
    // etc
}
```

Жизненный цикл имеет 3 состояния: работает, выключается и терминирован.

Метод shutdown инициализирует завершение работы ExecutorService. Новые задачи, приходящие в submit отправляются в 
очередь отмененных задач, однако уже принятые задачи будут ожидать выполнения. После завершения всех задач из очереди, 
ExecutorService переводится в терминированный статус.

Метод shutdownNow пытается отменить невыполненные задачи и не берет в работу задачи из очереди ожидания.

Попробуем дописать наш веб сервер с поддержкой жизненного цикла веб сервера:

```java
class LifecycleWebServer {
    private static final int NUMBER_THREADS = 100;
    private static final Executor executor = Executors.newFixedThreadPool(NUMBER_THREADS);
    
    public void start() {
        ServerSocket server = new ServerSocket(80);
        while (!executor.isShutdown()) {
            final Socket connection = server.accept();
            executor.execute(() -> handleRequest(connection));
        }
    }
    
    public void stop() {
        executor.shutdown();
    }
}
```

#### Отложенные и периодические задачи