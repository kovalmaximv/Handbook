# Атомарные переменные и неблокирующая синхронизация
В качестве альтернатив замковым алгоритмам есть неблокирующая синхронизация. Она предлагает улучшенную 
масштабируемость и жизнеспособность. Возможно это благодаря тому, что они не блокируются в случае конфликтного ресурса и 
как следствие, невосприимчивы к блокировкам и другим проблемам жизнеспособности.

В противовес плюсам, неблокирующие алгоритмы сложнее проектировать и реализовывать. 

В Java для реализации неблокирующих алгоритмов используются атомарные классы (AtomicInteger, AtomicReference, etc).

## Недостатки замковой защиты
Если замок заблокирован и поток блокируются, JVM может обратиться к ОС для блокирования потока. Блокировка и 
разблокировка имеет много издержек (переключение контекста, ожидание выделенных тиков процессора, етс).

Кроме того, когда поток ожидает замка, он не может ничего делать. Если замком сейчас владеет более низко 
приоритетный поток, то более высокоприоритетный замок будет ждать и бездействовать. Это называется инверсия приоритетов.

Замковый механизм очен тяжеловесен, иногда нам было бы достаточно волатильных переменных, способных изменяться атомарно.
К счастью, современные процессоры предоставляют такой механизм.

## Аппаратная поддержка конкурентности
Защита при помощи замка - пессимистичное техническое решение. Оно исходит из худшего и гарантирует, что если вы 
приобрели замок, другие потоки не будут мешать выполнению вашего кода.

Существует другой, оптимистичный подход. При таком подходе вы выполняете код в надежде, что сможете завершить его 
без вмешательства. Этот подход основан на обнаружении коллизии. Если при попытке выполнения произошло вмешательство 
со стороны других потоков, операция дает сбой и возможность повторной попытки.

Современные процессоры предоставляют специальные операции, которые выполняются атомарно. Нас интересует операция 
"сравнить и обменять" (Compare and swap, CAS). ОС и JVM используют эти инструкции для реализации замков. 

Операция CAS имеет ячейку памяти, старое значение в ячейке и новое желаемое значение ячейки. CAS атомарно обновляет 
ячейку, если ее значение соответствует ожидаемому старому значению. В противном случае CAS ничего не делает. 
В любом случае CAS возвращает значение, находящееся в ячейке в данный момент.

Когда многочисленные потоки пытаются обновить одну и ту же переменную одновременно с помощью CAS, один поток выигрывает 
и обновляет переменную, а другие проигрывают. Проигравшие потоки могут попробовать обновить переменную еще раз. Стоит 
отметить, что здесь нет блокировки и потоки в любой момент времени могут принять решение об остановке попыток. Эта 
гибкость избавляет от проблем жизнеспособности.

Начиная в Java 5 в язык добавлена низкоуровневая поддержка CAS, которая используется в атомарных классах. Если процессор 
платформы не поддерживает CAS, то JVM использует замок на основе холостого цикла.

## Атомарные классы