# Атомарные переменные и неблокирующая синхронизация
В качестве альтернатив замковым алгоритмам есть неблокирующая синхронизация. Она предлагает улучшенную 
масштабируемость и жизнеспособность. Возможно это благодаря тому, что они не блокируются в случае конфликтного ресурса и 
как следствие, невосприимчивы к блокировкам и другим проблемам жизнеспособности.

В противовес плюсам, неблокирующие алгоритмы сложнее проектировать и реализовывать. 

В Java для реализации неблокирующих алгоритмов используются атомарные классы (AtomicInteger, AtomicReference, etc).

## Недостатки замковой защиты
Если замок заблокирован и поток блокируются, JVM может обратиться к ОС для блокирования потока. Блокировка и 
разблокировка имеет много издержек (переключение контекста, ожидание выделенных тиков процессора, етс).

Кроме того, когда поток ожидает замка, он не может ничего делать. Если замком сейчас владеет более низко 
приоритетный поток, то более высокоприоритетный замок будет ждать и бездействовать. Это называется инверсия приоритетов.

Замковый механизм очен тяжеловесен, иногда нам было бы достаточно волатильных переменных, способных изменяться атомарно.
К счастью, современные процессоры предоставляют такой механизм.

## Аппаратная поддержка конкурентности
Защита при помощи замка - пессимистичное техническое решение. Оно исходит из худшего и гарантирует, что если вы 
приобрели замок, другие потоки не будут мешать выполнению вашего кода.

Существует другой, оптимистичный подход. При таком подходе вы выполняете код в надежде, что сможете завершить его 
без вмешательства. Этот подход основан на обнаружении коллизии. Если при попытке выполнения произошло вмешательство 
со стороны других потоков, операция дает сбой и возможность повторной попытки.

Современные процессоры предоставляют специальные операции, которые выполняются атомарно. Нас интересует операция 
"сравнить и обменять" (Compare and swap, CAS). ОС и JVM используют эти инструкции для реализации замков. 

Операция CAS имеет ячейку памяти, старое значение в ячейке и новое желаемое значение ячейки. CAS атомарно обновляет 
ячейку, если ее значение соответствует ожидаемому старому значению. В противном случае CAS ничего не делает. 
В любом случае CAS возвращает значение, находящееся в ячейке в данный момент.

Когда многочисленные потоки пытаются обновить одну и ту же переменную одновременно с помощью CAS, один поток выигрывает 
и обновляет переменную, а другие проигрывают. Проигравшие потоки могут попробовать обновить переменную еще раз. Стоит 
отметить, что здесь нет блокировки и потоки в любой момент времени могут принять решение об остановке попыток. Эта 
гибкость избавляет от проблем жизнеспособности.

Начиная в Java 5 в язык добавлена низкоуровневая поддержка CAS, которая используется в атомарных классах. Если процессор 
платформы не поддерживает CAS, то JVM использует замок на основе холостого цикла.

## Атомарные классы
Неоспариваемое обновления атомарной переменной обычно быстрее, чем неоспариваемое приобретение замка. Оспариваемое 
обновление атомарной операции гораздо быстрее, чем оспариваемое приобритение замка.

Существуют следующие группы атомарных классов: скаляры, обновители полей, массивы, составные переменные. Чаще всего 
используются скаляры (AtomicInteger, AtomicLong, AtomicReference, etc). 

#### Атомарные составные переменные
Допустим, что инвариант состоит из двух зависимых переменных. Использовать две атомарные переменные нельзя, поскольку
не получится обновить две таких переменные атомарно. Между обновлением первой и второй будет лаг, во время которого 
могут вмешаться другие потоки.

В таких случаях следует использовать атомарные ссылки (AtomicReference) cо ссылкой на составной немутируемый класс из 
двух переменных. Такой класс атомарно обновит ссылку на немутируемый объект состояния.

Например, у нас есть класс NumberRange, который хранит две переменные lower и upper. Переменная lower всегда должна 
быть ниже upper. Решение с AtomicReference будет выглядеть таким образом:
```java
public class NumberRange { 
    
    private static class IntPair {
        // Инвариант lower <= upper
        final int upper;
        final int lower;
    }
    
    private final AtomicReference<IntPair> values = new AtomicReference<>(new IntPair(0, 0));
    
    public int getLower() { return values.get().lower; }
    public int getUpper() { return values.get().upper; }
    
    public void setLower(int num) {
        while (true) {
            IntPair oldv = values.get();
            if (i > oldv.upper) {
                throw new IllegalArgumentException();
            }
            IntPair newv = new IntPair(i, oldv.upper);
            if (values.compareAndSet(oldv, newv)){
                return;
            }
        }
    }
    
    // аналогично для setUpper
}
```
#### Сравнение производительности замков и атомарных переменных
При высоких уровнях конфликта замок превосходит атомарные переменные, но на более реалистичных уровнях конфликта 
атомарные переменные превосходят замки. 

На практике атомарные переменные масштабируются лучше, чем замки, потому что атомарные объекты более эффективно 
справляются с типичными уровнями конфликта.

## Примеры неблокирующих алгоритмов (использование атомарных переменных)
Неблокирующий алгоритм - если приостановка одного потока не может вызвать приостановку другого потока.  
Беззамковый алгоритм - если на каждом шаге любой из потоков может продвигаться вперед.

Алгоритмы, которые используют CAS правильно, могут стать беззамковыми и неблокирующими одновременно.

Для всех распространенных структур данных известы свои неблокирующие аналоги.

#### Пример: неблокирующий стек
Ключом к созданию неблокирующего алгоритма является выяснение, как собрать все изменяющиеся данные в одну 
атомарную переменную. В классах связных коллекций иногда достаточно использовать AtomicReference для хранения объектов 
со значением и ссылками.

Пример такого подхода в реализации стека:

```java
import java.util.concurrent.atomic.AtomicReference;

public class NonBlockingStack<T> {
    
    public static class Node <T> {
        public final T item;
        public Node<T> next;
    }
    
    AtomicReference<Node<T>> top = new AtomicReference<>();
    
    public void push(T item) {
        Node<T> newHead = new Node<T>(item);
        Node<T> oldHead;
        do {
            oldHead = top.get();
            newHead.next = oldHead;
        } while (!top.compareAndSet(oldHead, newHead));
    }
    
    public T pop() {
        Node<T> oldHead;
        Node<T> newHead;
        do {
            oldHead = top.get();
            if (oldHead == null) {
                return null;
            }
            newHead = oldHead.next;
        } while (!top.compareAndSet(oldHead, newHead));
        return oldHead.item;
    }
}
```
#### Пример: неблокирующий связный список
Хитрость построения неблокирующих алгоритмов в ограничении атомарных изменений одной переменной. Для связного списка это
нетривиальная задача.

Для успешной вставки нового элемента нужно обновлять два указателя. Кажется, будто это невозможно, ведь это потребует 
двух отдельных CAS операций. Между операциями может встрять другой поток. 

Для решения этой проблемы нужны две хитрости:
1) Нужно чтобы структура данных всегда была в непротиворечивом состоянии, даже в середине многошагового обновления. 
Этой хитрости хватило бы, если бы все потоки работали со структурой не повреждая ее, однако это невозможно.
2) Если поток B начинает работу и видит структуру в середине обновления потоком А, то поток B сначала заканчивает 
обновления потока А, а потом приступает к своим изменениям.

Пример неблокирующего связного списка:

```java
import java.util.concurrent.atomic.AtomicReference;

public class LinkedQueue<T> {
    private static class Node<T> {
        final T item;
        final AtomicReference<Node<T>> next;
    }
    
    private final Node<T> initialNode = new Node<>(null, null);
    private final AtomicReference<Node<T>> head = new AtomicReference<>(initialNode);
    private final AtomicReference<Node<T>> tail = new AtomicReference<>(initialNode);
    
    public boolean put(T item) {
        Node<T> newNode = new Node<>(item, null);
        while (true) {
            Node<T> currentTail = tail.get();
            Node<T> tailNext = currentTail.next.get();
            if (currentTail == tail.get()) {
                if (tailNext != null) {
                    // Последний элемент на самом деле не последний 
                    // Значит, очередь в промежуточном состоянии. Надо использовать хитрость 2
                    // Надо подвинуть хвост вперед
                    tail.compareAndSet(currentTail, tailNext);
                } else {
                    // Очередь в законченном состоянии, можно вставлять новый элемент
                    if (currentTail.next.compareAndSet(null, newNode)) {
                        // Вставка успешна, пытаемся двинуть хвост вперед
                        tail.compareAndSet(currentTail, newNode);
                        return true;
                    }
                }
            }
        }
    }
}
```

## Обновители атомарных полей
Классы обновителей атомарных полей используются для обновлений волатильных переменных. Это может быть полезно, чтобы 
не создавать атомарные объекты, что является дорогой операцией, если делать это для большой коллекции.

Классы обновители не привязаны к конкретному экземпляру, их можно использовать для обновления поля любого экземпляра.

Гарантии атомарности для классов обновителей ниже, поскольку нельзя гарантировать, что базовые поля не будут 
изменены непосредственно.

```java
private static Node<T> {
    private final T item;
    private volatile Node<T> next;
}

private static AtomicReferenceFieldUpdater<Node, Node> nextUpdater = 
        AtomicReferenceFieldUpdater.newUpdater(Node.class, Node.class, "next");
```

Во всех других случаях (когда не нужна лишняя оптимизация), атомарные классы работают просто отлично.

## Проблема ABA
Операция CAS фактически спрашивает "значение ячейки V все еще равно A?" и продолжает обновление, если это так. В 
большинстве случаев этого достаточно. Но представим, что между опросом CAS произошло обновление ячейки A->B->A. В 
некоторых случаях это может означать, что обновлять ячейку нельзя (хоть ее значение по сути и осталось A->A).

В таких случаях надо вводить версионность поля. Класс AtomicStampedReference поддерживает версионность 
обновляемого значения.

# Итоги
- Неблокирующие алгоритмы обеспечивают потокобезопасность с помощью атомарных операций процессора (которые используют
атомарные классы Java).
- Неблокирующие алгоритмы трудны в проектировании и реализации, но могут предложить улучшенную масштабируемость и более
высокую устойчивость к проблемам жизнеспособности.