# Совместное использование объектов
## Видимость
В многопоточной среде, если запись и чтение некоторого объекта разбиты по разным потокам, то поток чтения может 
просто не увидеть изменения в объекте. Чтобы обеспечить видимость изменения памяти в различных потоках, вы должны 
использовать синхронизацию.

Взглянем на пример. 

```java
@NotThreadSafe
public class NoVisibility {
    private static boolean ready;
    private static int number;
    
    private static class ReaderThread extends Thread {
        public void run() {
            while (!ready) 
                Thread.yield();
            
            System.out.println(number);
        }
    }

    public static void main(String[] args) {
        new ReaderThread().start();
        number = 42;
        ready = true;
    }
}
```
Два потока, главный и читающий обращаются к совместным переменным `ready` и `number`.  
Главный поток запускает `ReaderThread`, устанавливает значение `number`, устанавливает флаг `ready`.  
Читающий поток видит новое значение флага и распечатывает значение `number`, **но этого может не произойти**.

Читающий поток может попасть в бесконечный цикл, если значение `ready` не видимо для него. Или напечатать ноль, если 
операция `ready` станет видимой читающему потоку _перед_ записью `number` (явление называемое переупорядочивание). Нет
гарантий, что операции в потоке будут выполняться в заданном программном порядке.

> :exclamation: **Без синхронизации компилятор, процессор и рабочая среда могут перепутать порядок выполнения операций.**

> :exclamation: **Необходимо применять синхронизацию, когда данные используются потоками совместно.**

#### Устаревшие данные
Класс `NoVisibility` демонстрирует появление устаревших данных (_stale data_), которые видит читающий поток, если не 
используется синхронизация для доступа к данным. Но из-за переупорядочивания, могут быть ситуации похуже, когда 
поток видит актуальное значение одной переменной и устаревшее значение другой, которая программно должна 
была измениться раньше.

Пример ниже не является потокобезопасным и так же подвержен появлению устаревших данных.
```java
@NotThreadSafe
public class MutableInteger {
    private int value;
    
    public int get() { return value; }
    public void set(int value) { this.value = value; }
}
```

Доступ к полю `value` осуществляется из двух методов без синхронизации. Читающие потоки, использующие `get()` 
могут просто не увидеть изменения. Исправить пример можно следующим образом:

```java
@NotThreadSafe
public class MutableInteger {
    private int value;
    
    public synchronized int get() { return value; }
    public synchronized void set(int value) { this.value = value; }
}
```

#### Блокировка и видимость