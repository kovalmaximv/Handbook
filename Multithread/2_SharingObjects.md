# Совместное использование объектов
## Видимость
В многопоточной среде, если запись и чтение некоторого объекта разбиты по разным потокам, то поток чтения может 
просто не увидеть изменения в объекте. Чтобы обеспечить видимость изменения памяти в различных потоках, вы должны 
использовать синхронизацию.

Взглянем на пример. 

```java
@NotThreadSafe
public class NoVisibility {
    private static boolean ready;
    private static int number;
    
    private static class ReaderThread extends Thread {
        public void run() {
            while (!ready) 
                Thread.yield();
            
            System.out.println(number);
        }
    }

    public static void main(String[] args) {
        new ReaderThread().start();
        number = 42;
        ready = true;
    }
}
```
Два потока, главный и читающий обращаются к совместным переменным `ready` и `number`.  
Главный поток запускает `ReaderThread`, устанавливает значение `number`, устанавливает флаг `ready`.  
Читающий поток видит новое значение флага и распечатывает значение `number`, **но этого может не произойти**.

Читающий поток может попасть в бесконечный цикл, если значение `ready` не видимо для него. Или напечатать ноль, если 
операция `ready` станет видимой читающему потоку _перед_ записью `number` (явление называемое переупорядочивание). Нет
гарантий, что операции в потоке будут выполняться в заданном программном порядке.

> :exclamation: **Без синхронизации компилятор, процессор и рабочая среда могут перепутать порядок выполнения операций.**

> :exclamation: **Необходимо применять синхронизацию, когда данные используются потоками совместно.**

#### Устаревшие данные
Класс `NoVisibility` демонстрирует появление устаревших данных (_stale data_), которые видит читающий поток, если не 
используется синхронизация для доступа к данным. Но из-за переупорядочивания, могут быть ситуации похуже, когда 
поток видит актуальное значение одной переменной и устаревшее значение другой, которая программно должна 
была измениться раньше.

Пример ниже не является потокобезопасным и так же подвержен появлению устаревших данных.
```java
@NotThreadSafe
public class MutableInteger {
    private int value;
    
    public int get() { return value; }
    public void set(int value) { this.value = value; }
}
```

Доступ к полю `value` осуществляется из двух методов без синхронизации. Читающие потоки, использующие `get()` 
могут просто не увидеть изменения. Исправить пример можно следующим образом:

```java
@NotThreadSafe
public class MutableInteger {
    private int value;
    
    public synchronized int get() { return value; }
    public synchronized void set(int value) { this.value = value; }
}
```

Блокировка замком может использоваться для того, чтобы гарантировать видимость действий одного потока другим. 
Без синхронизации видимость не гарантирована. 

## Волатильные переменные
Java предоставляет так же более слабую форму синхронизации, _волатильные переменные_.

Переменная _volatile_ для компилятора и рабочей среды является совместной, то есть операции над ней не будут
переупорядочены с другими операциями в памяти. Так же волатильные переменные не кешируются в регистрах, 
где их данные скрыты от других процессов, поэтому их чтение всегда возвращает самый последний результат операции записи.

Типичный пример использования волатильных переменных:
```java
volatile boolean asleep;

while (!asleep)
    countSomeSheep();
```
Флаг `asleep` в данном коде должен быть волатильным, иначе поток может не заметить, когда флажок изменит другой поток.

Волатильные переменные недостаточны сильны, чтобы сделать операцию инкремента атомарной в многопоточной среде.

> :exclamation: **Блокировка может гарантировать как видимость, так и атомарность. 
> Волатильные переменные гарантируют только видимость.**

## Публикация и ускользание
Публикация (publishing) объекта, означает передать его за пределы текущей области действия. Например, 
ссылка на объект может быть возвращена из метода. Публикация объекта до момента их полного конструирования ставит под 
угрозу потокобезопасность. 

Объект, который не вовремя публикуется, называется ускользнувшим (escaped).

#### Формы публикации:
1) Ссылка в публичном статическом поле.
```java
public static Set<Secret> knownSecret;

public void initialize() {
    knownSecret = new HashSet<Secret>();
}
```
Публикация одного объекта может косвенно опубликовать и другие. Если добавить секрет в Set из примера выше, то он 
также опубликуется. Схожим образом возвращение ссылки из публичного метода заодно публикует возвращаемый объект:
```java
```