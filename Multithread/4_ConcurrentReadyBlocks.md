# Строительные блоки
## Синхронизированные коллекции
Синхронизированные классы коллекций (Synchronized collection classes) - Vector, Hashtable, а также добавленные 
в JDK 1.2 синхронизированные оберточные классы (создаваемые методами Collections.synchronizedXxx).

Эти классы обеспечивают потокобезопасность, инкапсулируя свое состояние и синхронизируя каждый публичный метод таким 
образом, чтобы только один поток за один раз мог обратиться к состоянию коллекции.

#### Проблемы синхронизированных коллекций
Синхронизированные коллекции являются потокобезопасными, но в некоторых случаях, когда потоки могут изменять 
коллекцию конкурентно, требуется блокировка на стороне клиента для защиты составных действий. 

Такими действиями могут быть: итеративный обход, навигация (поиск элемента) и условные операции 
(связывание ключа со значением).

Рассмотрит пример составных действий над объектов Vector:
```java
public Object getLast(Vector list) {
    int lastIndex = list.size() - 1;
    return list.get(lastIndex);
}

public void deleteLast(Vector list) {
    int lastIndex = list.size() - 1;
    list.remove(lastIndex);
}
```

Если вызвать два метода одновременно и первым отработает метод deleteLast, а после getLast с одинаковыми индексами, то
мы получим ошибку ArrayIndexOutOfBoundsException.

Решить эту проблему можно, приобретая замок, на время выполнения методов:
```java
public Object getLast(Vector list) {
    synchronized(list) {
        int lastIndex = list.size() - 1;
        return list.get(lastIndex);
    }
}

public void deleteLast(Vector list) {
    synchronized(list){
        int lastIndex=list.size()-1;
        list.remove(lastIndex);
    }
}
```

Даже итеративный обход по коллекции может выдавать исключение ArrayIndexOutOfBoundsException, так как в параллельных
потоках кто-то может изменять эту коллекцию. В данном случае можно так же приобрести замок на время итерации, однако 
стоит помнить, что от такого подхода страдает конкурентность, другие потоки будут ждать окончания итерации по коллекции.

#### Итераторы и исключения ConcurrentModificationException
Итеративный обход объекта Collection заключается в использовании объекта Iterator. Итераторы потокобезопасных 
синхронизированных коллекций не проектировались для конкурентного доступа, поэтому обнаружив во время итеративного
обхода изменения в коллекции, они выдают исключение ConcurrentModificationException (принцип быстрого отказа _fail-fast_).

Таким образом итераторы просто сигнализируют о проблеме в конкурентности. 

Решение данной проблемы - приобретение замка на время итерации:
```java
List<Object> objectList = Collections.synchronizedList(new ArrayList<Object>());

synchronized(objectList) {
    for (Object obj: objectList) {
        doSomething(obj);
    }    
}
```

Однако такой подход не всегда уместен. При больших коллекциях или тяжелых методах обработки ожидание 
завершения итерации может быть большим. Появляется фактор риска взаимной блокировки, так же снижается масштабируемость 
приложения. 

Альтернативой к запиранию коллекции является запирание клона коллекции. Клон ограничен одним поток, однако все 
равно необходима блокировка на время итерации при создании клона коллекции.

Стоит помнить так же про скрытые итераторы. Обнаружить их довольно сложно, если не знать, где он точно есть. В качестве
примера можно привести toString метод, который в коллекциях проводит итеративный обход.

## Конкурентные коллекции