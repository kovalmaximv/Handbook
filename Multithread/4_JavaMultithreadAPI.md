# Строительные блоки
## Синхронизированные коллекции
Синхронизированные классы коллекций (Synchronized collection classes) - Vector, Hashtable, а также добавленные 
в JDK 1.2 синхронизированные оберточные классы (создаваемые методами Collections.synchronizedXxx).

Эти классы обеспечивают потокобезопасность, инкапсулируя свое состояние и синхронизируя каждый публичный метод таким 
образом, чтобы только один поток за один раз мог обратиться к состоянию коллекции.

#### Проблемы синхронизированных коллекций
Синхронизированные коллекции являются потокобезопасными, но в некоторых случаях, когда потоки могут изменять 
коллекцию конкурентно, требуется блокировка на стороне клиента для защиты составных действий. 

Такими действиями могут быть: итеративный обход, навигация (поиск элемента) и условные операции 
(связывание ключа со значением).

Рассмотрит пример составных действий над объектов Vector:
```java
public Object getLast(Vector list) {
    int lastIndex = list.size() - 1;
    return list.get(lastIndex);
}

public void deleteLast(Vector list) {
    int lastIndex = list.size() - 1;
    list.remove(lastIndex);
}
```

Если вызвать два метода одновременно и первым отработает метод deleteLast, а после getLast с одинаковыми индексами, то
мы получим ошибку ArrayIndexOutOfBoundsException.

Решить эту проблему можно, приобретая замок, на время выполнения методов:
```java
public Object getLast(Vector list) {
    synchronized(list) {
        int lastIndex = list.size() - 1;
        return list.get(lastIndex);
    }
}

public void deleteLast(Vector list) {
    synchronized(list){
        int lastIndex=list.size()-1;
        list.remove(lastIndex);
    }
}
```

Даже итеративный обход по коллекции может выдавать исключение ArrayIndexOutOfBoundsException, так как в параллельных
потоках кто-то может изменять эту коллекцию. В данном случае можно так же приобрести замок на время итерации, однако 
стоит помнить, что от такого подхода страдает конкурентность, другие потоки будут ждать окончания итерации по коллекции.

#### Итераторы и исключения ConcurrentModificationException
Итеративный обход объекта Collection заключается в использовании объекта Iterator. Итераторы потокобезопасных 
синхронизированных коллекций не проектировались для конкурентного доступа, поэтому обнаружив во время итеративного
обхода изменения в коллекции, они выдают исключение ConcurrentModificationException (принцип быстрого отказа _fail-fast_).

Таким образом итераторы просто сигнализируют о проблеме в конкурентности. 

Решение данной проблемы - приобретение замка на время итерации:
```java
List<Object> objectList = Collections.synchronizedList(new ArrayList<Object>());

synchronized(objectList) {
    for (Object obj: objectList) {
        doSomething(obj);
    }    
}
```

Однако такой подход не всегда уместен. При больших коллекциях или тяжелых методах обработки ожидание 
завершения итерации может быть большим. Появляется фактор риска взаимной блокировки, так же снижается масштабируемость 
приложения. 

Альтернативой к запиранию коллекции является запирание клона коллекции. Клон ограничен одним поток, однако все 
равно необходима блокировка на время итерации при создании клона коллекции.

Стоит помнить так же про скрытые итераторы. Обнаружить их довольно сложно, если не знать, где он точно есть. В качестве
примера можно привести toString метод, который в коллекциях проводит итеративный обход.

## Конкурентные коллекции
Синхронизированные коллекции обеспечивают потокобезопасность, синхронизируя весь доступ к своему состоянию. Минус такого
подхода - слабая конкурентность, точнее ее отсутствие: работа с такой коллекцией становится последовательной (обратно 
конкурентности). 

По этой причине в Java 5 появились конкурентные (_concurrent_) коллекции.

> :exclamation: **Конкурентные коллекции предоставляют лучшую масштабируемость и быстродействие, при небольших 
> особенностях при работе с ними.**

#### ConcurrentHashMap
Класс ConcurrentHashMap - хешированный ассоциативный массив Map (почти как HashMap), но использующий 
блокирование сегмента (_segment locking_), вместо синхронизации методов. 

Суть метода блокирование сегмента в том, что вся мапа делится на сегменты, Entry в этих сегментах в идеале 
расположены равномерно для большей производительности. Связь между ключом и сегментом основывается на первых 
битах хеша.

Чтение из ConcurrentHashMap происходит без блокирования. Любое изменение ConcurrentHashMap блокирует сегмент, в 
котором происходят изменения. Таким образом достигается конкурентность коллекции. Несколько потоков одновременно 
могут изменять коллекцию и бесконечно кол-во потоков могут читать из этой коллекции.

Также класс ConcurrentHashMap предоставляет итераторы, которые не выдают ConcurrentModificationException. Вместо этого, 
они допускают конкурентное выполнение изменений, но перебирают элементы в том порядке, в каком они были при создании 
итератора и могут не содержать последних изменений.

Подводные камни:
1) Операции чтения не блокируют сегменты, так что они могут выдавать устаревшие данные.
2) Агрегатные операции (size, isEmpty, containsValue) имеют смысл только если конкурентно запросу никто 
не изменяет коллекцию.
3) Вместо size лучше использовать mappingCount.
4) Стоит помнить про операции "проверить, затем действовать". Для такой стратегии стоит использовать 
putIfAbsent метод.

#### CopyOnWriteArrayList
CopyOnWriteArrayList является конкурентная версия синхронизированного списка. 

При изменении коллекции, создается и публикуется копия этой коллекции, которую позже используют итераторы 
для обхода.

Стоит помнить, что операция копирования может быть дорогостоящая, поэтому коллекцию целесообразно использовать, 
когда итеративный обход встречается гораздо чаще изменений коллекции.

## Блокирующие очереди 
Блокирующие очереди предоставляют блокирующие методы put и take. 

`put` добавляет элемент в очередь, но если очередь полная, то метод блокируется, пока в очереди не появится место.  
`take` читает элемент из очереди, но если очередь пустая, то метод блокируется, пока в очереди не появятся данные.

#### Паттерн producer-consumer
Паттерн producer-consumer заключается в использовании блокирующей очереди между потребителем и производителем, чтобы 
потребитель не сразу обрабатывал сообщения, а по мере возможности.

Блокирующая очередь в данном паттерне упрощает рабочей нагрузкой, путем блокирования потребителей или производителей 
в зависимости от условий очереди.

В качестве примера можно представить двух человек, один из которых моет посуду и помещает в стеллаж, а другой 
человек забирает из стеллажа и сушит. Стеллаж в данном примере работает как блокирующая очередь. Если очередь 
пустая, то потребитель ждет появления тарелок, ничего в этот момент не делая, а если очередь полная, то 
производитель ждет, пока появится место. Таким образом, простой не потребляет лишних ресурсов и управляет нагрузкой.

> :exclamation: **Ограниченные очереди устойчивее к перегрузкам.**

Двухсторонние очереди позволяет реализовать паттерн кража работы (_work stealing_). В данном паттерне 
каждый потребитель имеет свою очередь. Если потребитель исчерпывает всю работу в своей очереди, он может 
украсть работу из чужой (крадет с хвоста).

## Блокирующие и прерываемые методы
Потоки могут блокировать продвижение, если ожидают завершения ввода-вывода, приобретения замка, пробуждение ото сна 
или результата вычислений в другом потоке. При блокировании они помещаются в состояние BLOCKED, WAITING, 
TIMED_WAITING.

Методы put и take класса BlockingQueue выдают проверяемое исключение InterruptedException (такое же исключение 
выдают и другие библиотечные методы, например Thread.sleep). Данное исключение отличает блокирующие методы, 
которые не хотят собственноручно прерывать поток. 

Прерывание представляет собой кооперативный механизм. Когда поток А пытается прервать поток B, он на самом деле 
просто просит поток B прервать самого себя. Отменой длительных действий занимаются не потоки, а блокирующие методы.

Вызывая метод, который выдает исключение InterruptedException ваш метод так же становится блокирующим и должен уметь 
откликаться на прерывание. Есть 2 способа:
1) Передать исключение InterruptedException выше по стеку
В данном случае исключение надо вынести в сигнатуру метода, в надежде что кто-то выше по стеку вызовов его обработает.
2) Провести прерывание
В таком случае необходимо вызвать метод interrupt в текущем потоке.

На самом деле, вариантов еще много, но единственное, что вы не должны делать - отлавливать исключение и ничего 
не делать. Это лишает поток выполнения прерывания.

## Синхронизаторы
Синхронизатор (synchronizer) - объект, координирующий (блокирующий) другие потоки, основываясь на своем состоянии.

В качестве синхронизаторов могут выступать блокирующие очереди, семафоры, барьеры и защелки.

#### Защелка (latch)
Защелка (latch) - блокирует потоки до достижения своего конечного состояния.

Обычно защелки используются, когда нужно сдерживать некие действия до завершения других важных действий:
1) Инициализация ресурсов
2) Готовность всех участников
3) etc

Класс CountDownLatch представляет собой реализацию защелки. Его состояние состоит из счетчика, 
который инициализируется положительным числом ожидаемых событий. Метод countDown уменьшает счетчик, а метод await 
ожидает до тех пор, пока счетчик не достигнет нуля.

Пример, измеряющий время выполнения задачи n раз конкурентно:

```java
import java.util.concurrent.CountDownLatch;

public class TestLatch {
    public long timeTasks(int nThreads, final Runnable task) throws InterruptedException {
        final CountDownLatch startGate = new CountDownLatch(1);
        final CountDownLatch endGate = new CountDownLatch(nThreads);

        for (int i = 0; i < nThreads; i++) {
            Thread t = new Thread(() -> {
                try {
                    startGate.await();
                    try {
                        task.run();
                    } finally {
                        endGate.countDown();
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            })
            t.start();
        }
        
        long start = System.nanoTime();
        startGate.countDown();
        endGate.await();
        long end = System.nanoTime();
        return end - start;
    }
}
```

Данный пример создает несколько потоков, выполняющих одну задачу конкурентно и использует две защелки: 
начальную (инициализируется числом 1) и конечную (инициализируется числом потоков). Потоки ожидают на начальной 
защелке готовности к запуску, а основной поток выполнения поток ждет на конечной защелке завершения всех потоков.

#### FutureTask
FutureTask действует схоже с защелкой, он реализует Future, описывающий абстрактные вычисления, приносящие результат.

FutureTask может находиться в состоянии ожидании выполнения, выполнения, либо завершения (нормального, отмены 
или прерывания). FutureTask приняв завершающее состояние остается в нем навсегда.

Поведение Future.get зависит от состояния. Если она завершена, метод возвратит результат немедленно. В противном 
случае он будет блокировать продвижение до тех пор, пока задача не перейдет в состояние завершения.

Рассмотрим пример, который поддерживает выполнение дорогостоящей операции до того, как необходим результат:

```java
public class Preloader {
    private final FutureTask<ProductionInfo> future =
            new FutureTask<ProductionInfo>((Callable<ProductionInfo>) () -> loadProductInfo());

    private final Thrad thread = new Thread(future);

    public void start() {
        thread.start();
    }

    public ProductionInfo get() {
        try {
            return future.get();
        } catch (ExecutionException e) {
            Throwable cause = e.getCause();
            if (cause instanceof DataLoadException) {
                throw (DataLoadException) cause;
            } else if (cause instanceof RuntimeException) {
                throw new (RuntimeException) cause;
            } // etc 
        }
    }
}
```

Данный класс вызывает метод start() до того, как ему необходимы данные, таким образом к моменту, когда данные нужны, 
скорее всего будет получен ответ. Проблемы возникают только в блоке catch из-за неудобного механизма 
получения ошибки.

#### Семафоры
Счетные семафоры (_counting semaphores_) ограничивают число действий, способных выполняться одновременно.

Класс Semaphore управляет набором виртуальных разрешений (permits). Начальное число разрешений задается 
в конструкторе.

Потоки могут приобретать разрешения и освобождать их. Если свободных разрешений нет, то метод `acquire` блокирует 
продвижение до тех пор, пока свободных разрешений не появится. Метод `release` возвращает разрешение семафору.

Двоичный семафор с начальным значением 1 можно использовать в качестве мьютекса.

При помощи семафора можно любую коллекцию превратить в блокирующую коллекцию. Достаточно задать размер 
блокирующей коллекции в Семафор.

```java
public class BlockingSet<T> {
    private final Set<T> set;
    private final Semaphore semaphore;

    public BlockingSet(int bound) {
        this.set = Collections.synchronizedSet(new HashSet<>());
        semaphore = new Semaphore(bound);
    }
    
    public boolean add(T value) {
        semaphore.acquire();
        boolean wasAdded = set.add(value);

        if (!wasAdded) {
            semaphore.release();
        }
        return wasAdded;
    }
    
    public boolean remove(T value) {
        boolean wasRemoved = set.remove(value);
        
        if (wasRemoved) {
            semaphore.release();
        }
        return wasRemoved;
    }
}
```

#### Барьеры
Барьеры (_barriers_) подобно защелкам блокируют группу потоков до наступления какого-то действия. Разница в том, что 
барьер используется как накопитель, когда достаточное количество потоков готово продолжать работу, барьер пропускает 
все потоки дальше.

Защелки предназначены для ожидания событий, барьер для ожидания других потоков.

Пример из жизни: "Встретимся на улице N, оставайтесь там, пока все не соберутся. 
Когда все будут на месте, решим что делать."

Класс CyclicBarrier позволяет фиксированному числу сторон неоднократно запускать цикл ожидания других потоков. 
Он полезен в итеративных алгоритмах, которые разбивают задачу на подзадачу, а потом ждут, когда остальные 
потоки завершат свою работу. Потоки достигают барьерной точки, вызывают метод await, который блокирует продвижение, 
пока все потоки не сделают то же самое. Если барьер пройден, все потоки освобождаются, а барьер переустанавливается 
для следующего выполнения. 

## Практическая часть
Попробуем создать эффективный конкурентный кеш.

Есть некоторая высокозатратная функция:
```java
public class ExpensiveFunction {
    public long compute(String arg) {
        return expensiveOperation(arg);
    }
}
```
Результаты выполнения этой функции мы и будем сохранять.


Начнем с очевидного подхода, используем простой хеш-массив, и с каждым разом будем улучшать решение.
```java
@ThreadSafe
@BadPerformance
public class Memoizer1 {
    private final Map<String, Long> cache = new HashMap<>();
    private final ExpensiveFunction expensiveFunction;
    
    public class Memoizer1(ExpensiveFunction expensiveFunction) {
        this.expensiveFunction = expensiveFunction;
    }
    
    public synchronized Long compute(String arg) {
        Long result = cache.get(arg);
        if (result == null) {
            result = expensiveFunction.compute(arg);
            cache.put(arg, result);
        }
        return result;
    }
}
```
Данный способ потокобезопасен благодаря синхронности доступа к кешу, одна конкурентность данного подхода очень слабая.
Только один поток за раз можно обращаться к кешу, что по сути делает кеш однопоточным. 

Так же, до тех пор, пока значение не вычислилось, мы будем каждый раз пытаться его посчитать. Это может быть критично 
для тяжелой функции.

Попробуем использовать ConcurrentHashMap. Таким образом можно избавиться от синхронности доступа.

```java
@NotThreadSafe
@NormalPerformance
public class Memoizer2 {
    private final Map<String, Long> cache = new ConcurrentHashMap<>();
    private final ExpensiveFunction expensiveFunction;

    public class Memoizer2(ExpensiveFunction expensiveFunction) {
        this.expensiveFunction =expensiveFunction;
    }
    
    public Long compute(String arg) {
        Long result = cache.get(arg);
        if (result == null) {
            result = expensiveFunction.compute(arg);
            cache.put(arg, result);
        }
        return result;
    }
}
```

У этого класса есть ошибки в конкурентности. Если два потока одновременно пройдут условие `result == null`, то они 
вычислят одно и то же значение, что противоречит цели кеширования.

Попробуем это исправить, если наш ConcurrentHashMap будет хранить не результат вычисления, а Future с результатом.

```java
@NotThreadSafe
@NormalPerformance
public class Memoizer3 {
    private final Map<String, Future<Long>> cache = new ConcurrentHashMap<>();
    private final ExpensiveFunction expensiveFunction;

    public class Memoizer3(ExpensiveFunction expensiveFunction) {
        this.expensiveFunction =expensiveFunction;
    }

    public Long compute(String arg) {
        Future<Long> future = cache.get(arg);

        if (future == null) {
            Callable<Long> callable = () -> expensiveFunction.compute();
            future = new FutureTask<>(callable);
            cache.put(arg, future);
            future.compute(); // Вызов функции
        }
        try {
            return future.get();
        } catch() ...
    }
}
```

Данный пример все так же уязвим, потому что проблема "проверить, а затем действовать" с условным оператором все еще
на месте. Однако, мы уменьшили временное окно, в котором может произойти проблема, использовав Future.

Окончательно исправить все проблемы можно, если вместе с условным оператором использовать атомарный метод putIfAbsent.
```java
@ThreadSafe
@GoodPerformance
public class MemoizerFinal {
    private final Map<String, Future<Long>> cache = new ConcurrentHashMap<>();
    private final ExpensiveFunction expensiveFunction;

    public class MemoizerFinal(ExpensiveFunction expensiveFunction) {
        this.expensiveFunction =expensiveFunction;
    }

    public Long compute(String arg) {
        while (true) {
            Future<Long> future = cache.get(arg);

            if (future == null) {
                Callable<Long> callable = () -> expensiveFunction.compute();
                Future<Long> newFuture = new FutureTask<>(callable);
                future = cache.putIfAbsent(arg, newFuture);
                if (future == null) {
                    future = newFuture;
                    future.compute();
                }
            }
            try {
                return future.get();
            } catch(...) {
                cache.remove(arg, future);
                ...
            }
        }
        
    }
}
```

Так же мы избавились от грязных данных в кеше. Если какой-то Future упал с ошибкой, мы его удалим из кеша.